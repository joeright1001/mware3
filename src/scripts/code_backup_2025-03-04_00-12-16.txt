Code Output Generated at UTC: 2025-03-04_00-12-16
Generated by: codespace
----------------------------------------

=== Directory Structure: /src ===
.
├── config
│   ├── cors.js
│   └── database.js
├── routes
│   ├── admin
│   │   └── dashboard.js
│   └── public
│       ├── orders.js
│       └── payments.js
├── scripts
│   ├── code_backup_2025-03-03_00-22-47.txt
│   ├── code_backup_2025-03-03_23-58-43.txt
│   ├── code_backup_2025-03-04_00-12-16.txt
│   ├── delete_old_code_backup_files.sh
│   ├── project_code_output.sh
│   └── sql_script.sql
└── services
    ├── orders
    │   └── orderService.js
    ├── payments
    │   ├── alipayService.js
    │   ├── blinkService.js
    │   ├── btcpayService.js
    │   ├── expiry
    │   │   ├── expiryQueue.js
    │   │   ├── expiryService.js
    │   │   └── providers
    │   │       └── blinkExpiry.js
    │   ├── paymentService.js
    │   ├── paystatus
    │   │   ├── paymentStatusQueue.js
    │   │   ├── paymentStatusService.js
    │   │   └── providers
    │   │       ├── alipayPaymentStatus.js
    │   │       ├── blinkPaymentStatus.js
    │   │       ├── btcpayPaymentStatus.js
    │   │       ├── poliPaymentStatus.js
    │   │       └── stripePaymentStatus.js
    │   ├── poliService.js
    │   └── stripeService.js
    └── pdf
        └── pdfService.js

13 directories, 29 files
----------------------------------------

=== Directory Structure: /views ===
.
└── admin
    ├── error.ejs
    ├── order-details.ejs
    └── payments.ejs

1 directory, 3 files
----------------------------------------

=== Database Schema ===
Attempting to connect to database...

=== Table: pay_status ===
                                                                  Table "public.pay_status"
       Column       |           Type           | Collation | Nullable |                    Default                    | Storage  | Stats target | Description 
--------------------+--------------------------+-----------+----------+-----------------------------------------------+----------+--------------+-------------
 record_id          | integer                  |           | not null | nextval('pay_status_record_id_seq'::regclass) | plain    |              | 
 payments_record_id | integer                  |           | not null |                                               | plain    |              | 
 date_time          | timestamp with time zone |           | not null |                                               | plain    |              | 
 status             | text                     |           | not null |                                               | extended |              | 
 message            | text                     |           |          |                                               | extended |              | 
Indexes:
    "pay_status_pkey" PRIMARY KEY, btree (record_id)
Foreign-key constraints:
    "pay_status_payments_record_id_fkey" FOREIGN KEY (payments_record_id) REFERENCES payments(record_id)
Triggers:
    trg_update_pay_status AFTER INSERT OR UPDATE ON pay_status FOR EACH ROW EXECUTE FUNCTION update_pay_status()
Access method: heap

----------------------------------------

=== Table: orders ===
                                                                         Table "public.orders"
       Column        |           Type           | Collation | Nullable |                        Default                        | Storage  | Stats target | Description 
---------------------+--------------------------+-----------+----------+-------------------------------------------------------+----------+--------------+-------------
 trade_order         | text                     |           |          |                                                       | extended |              | 
 first_name_order    | text                     |           | not null |                                                       | extended |              | 
 last_name_order     | text                     |           |          |                                                       | extended |              | 
 email_order         | text                     |           |          |                                                       | extended |              | 
 phone_order         | text                     |           |          |                                                       | extended |              | 
 product_name_full   | text                     |           |          |                                                       | extended |              | 
 total_price         | text                     |           |          |                                                       | extended |              | 
 quantity            | text                     |           |          |                                                       | extended |              | 
 price_nzd           | text                     |           |          |                                                       | extended |              | 
 zoho_id             | text                     |           |          |                                                       | extended |              | 
 delivery            | text                     |           |          |                                                       | extended |              | 
 pay_in_person       | text                     |           |          |                                                       | extended |              | 
 checkbox_order      | text                     |           |          |                                                       | extended |              | 
 address             | text                     |           |          |                                                       | extended |              | 
 message             | text                     |           |          |                                                       | extended |              | 
 token               | text                     |           |          |                                                       | extended |              | 
 date_picker_order   | text                     |           |          |                                                       | extended |              | 
 time_picker_order   | text                     |           |          |                                                       | extended |              | 
 record_id           | integer                  |           | not null | nextval('orders_record_id_seq'::regclass)             | plain    |              | 
 order_creation_time | timestamp with time zone |           |          | timezone('Pacific/Auckland'::text, CURRENT_TIMESTAMP) | plain    |              | 
Indexes:
    "orders_pkey" PRIMARY KEY, btree (record_id)
Access method: heap

----------------------------------------

=== Table: expiry ===
                                                                  Table "public.expiry"
       Column       |           Type           | Collation | Nullable |                  Default                  | Storage  | Stats target | Description 
--------------------+--------------------------+-----------+----------+-------------------------------------------+----------+--------------+-------------
 record_id          | integer                  |           | not null | nextval('expiry_record_id_seq'::regclass) | plain    |              | 
 payments_record_id | integer                  |           | not null |                                           | plain    |              | 
 date_time          | timestamp with time zone |           | not null |                                           | plain    |              | 
 status             | text                     |           | not null |                                           | extended |              | 
 message            | text                     |           |          |                                           | extended |              | 
Indexes:
    "expiry_pkey" PRIMARY KEY, btree (record_id)
Foreign-key constraints:
    "expiry_payments_record_id_fkey" FOREIGN KEY (payments_record_id) REFERENCES payments(record_id)
Triggers:
    trg_update_expiry_status AFTER INSERT OR UPDATE ON expiry FOR EACH ROW EXECUTE FUNCTION update_expiry_status()
Access method: heap

----------------------------------------

=== Table: payments ===
                                                                  Table "public.payments"
     Column      |            Type             | Collation | Nullable |                   Default                   | Storage  | Stats target | Description 
-----------------+-----------------------------+-----------+----------+---------------------------------------------+----------+--------------+-------------
 record_id       | integer                     |           | not null | nextval('payments_record_id_seq'::regclass) | plain    |              | 
 order_record_id | integer                     |           |          |                                             | plain    |              | 
 created_at      | timestamp without time zone |           |          | CURRENT_TIMESTAMP                           | plain    |              | 
 provider        | character varying(50)       |           | not null |                                             | extended |              | 
 amount          | numeric(10,2)               |           | not null |                                             | main     |              | 
 status_url      | text                        |           |          |                                             | extended |              | 
 message_url     | text                        |           |          |                                             | extended |              | 
 payment_url     | text                        |           |          |                                             | extended |              | 
 status_pay      | character varying(50)       |           |          |                                             | extended |              | 
 message_pay     | text                        |           |          |                                             | extended |              | 
 payid           | character varying(255)      |           |          |                                             | extended |              | 
 expires_at      | timestamp with time zone    |           |          |                                             | plain    |              | 
 status_expiry   | text                        |           |          |                                             | extended |              | 
 reviewed        | text                        |           |          | 'no'::text                                  | extended |              | 
Indexes:
    "payments_pkey" PRIMARY KEY, btree (record_id)
Referenced by:
    TABLE "expiry" CONSTRAINT "expiry_payments_record_id_fkey" FOREIGN KEY (payments_record_id) REFERENCES payments(record_id)
    TABLE "pay_status" CONSTRAINT "pay_status_payments_record_id_fkey" FOREIGN KEY (payments_record_id) REFERENCES payments(record_id)
Access method: heap

----------------------------------------
----------------------------------------

=== File: /workspaces/mware3/server.js ===
/**
 * Main Application Entry Point with Streamlined Logging
 */

require("dotenv").config();
const express = require("express");
const cors = require("cors");
const path = require('path');
const rateLimit = require('express-rate-limit');
const winston = require('winston');
const fs = require('fs');

// Create directory for logs if it doesn't exist
if (!fs.existsSync('logs')) {
  fs.mkdirSync('logs');
}

// Configure Winston logger with custom formats
const consoleFormat = winston.format.printf(({ timestamp, level, message, component, ...meta }) => {
  // For website activity, create a minimal format
  if (meta.isWebRequest) {
    return `${timestamp} [${level}] ${meta.method} ${meta.url} ${meta.status} ${meta.duration}ms`;
  }
  
  // For regular logs, use a more readable format
  const metaStr = Object.keys(meta).length ? ` ${JSON.stringify(meta)}` : '';
  const comp = component ? `[${component}] ` : '';
  return `${timestamp} ${comp}${level}: ${message}${metaStr}`;
});

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp({
      format: 'YYYY-MM-DD HH:mm:ss'
    }),
    winston.format.errors({ stack: true })
  ),
  defaultMeta: { service: 'payment-server' },
  transports: [
    // Console output with custom formatting
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        consoleFormat
      )
    }),
    // Log files with JSON for later analysis
    new winston.transports.File({ 
      filename: 'logs/error.log', 
      level: 'error',
      format: winston.format.combine(
        winston.format.json()
      )
    }),
    new winston.transports.File({ 
      filename: 'logs/combined.log',
      format: winston.format.combine(
        winston.format.json()
      )
    })
  ]
});

// IMPORTANT: Replace console methods but DON'T double log
// This completely replaces the standard console functions
console.log = function(...args) {
  logger.info(args.join(' '));
};

console.error = function(...args) {
  logger.error(args.join(' '));
};

console.warn = function(...args) {
  logger.warn(args.join(' '));
};

console.info = function(...args) {
  logger.info(args.join(' '));
};

// Create specialized loggers for different components
const orderLogger = logger.child({ component: 'orders' });
const paymentLogger = logger.child({ component: 'payments' });
const adminLogger = logger.child({ component: 'admin' });
const systemLogger = logger.child({ component: 'system' });

// Import configurations
const corsOptions = require('./src/config/cors');

// Import routes
const orderRoutes = require('./src/routes/public/orders');
const paymentRoutes = require('./src/routes/public/payments');
const adminRoutes = require('./src/routes/admin/dashboard');

// Import payment status queue
const { paymentStatusQueue } = require('./src/services/payments/paystatus/paymentStatusQueue');

// Debug: Log environment variables
systemLogger.info('Environment variables loaded', {
    PORT: process.env.PORT ? 'Set' : 'Not Set',
    DATABASE_URL: process.env.DATABASE_URL ? 'Set' : 'Not Set',
    JWT_SECRET: process.env.JWT_SECRET ? 'Set' : 'Not Set',
    POLI_AUTH_CODE: process.env.POLI_AUTH_CODE ? 'Set' : 'Not Set',
    ADMIN_PASSWORD: process.env.ADMIN_PASSWORD ? 'Set' : 'Not Set'
});

const app = express();

// Trust proxy setting for rate limiting (important for Railway)
app.set('trust proxy', 1);

// Set up templating engine for admin dashboard
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));

// Middleware
app.use(cors(corsOptions));
app.use(express.json());

systemLogger.info('Middleware initialized');

// Add request logging middleware with streamlined output
app.use((req, res, next) => {
  const start = Date.now();
  res.on('finish', () => {
    const duration = Date.now() - start;
    
    // Only log with a simplified format for normal requests, more detail for errors
    if (res.statusCode >= 400) {
      logger.warn(`${req.method} ${req.url} ${res.statusCode} - ${duration}ms`, {
        method: req.method,
        url: req.url,
        status: res.statusCode,
        duration: duration,
        ip: req.ip,
        userAgent: req.get('User-Agent')
      });
    } else {
      // Use our custom format for web requests
      logger.info(`Web request processed`, {
        isWebRequest: true,
        method: req.method,
        url: req.url,
        status: res.statusCode,
        duration: duration
      });
    }
  });
  next();
});

// Admin route rate limiting
const adminLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later'
});

// Routes
app.use("/", orderRoutes);          // Base URL for order routes
app.use("/api", paymentRoutes);     // Payment status endpoint
app.use('/admin', adminLimiter, adminRoutes); // Admin dashboard routes

// Error handling middleware
app.use((err, req, res, next) => {
    logger.error('Global error encountered', { 
      error: err.message,
      stack: err.stack,
      url: req.url,
      method: req.method
    });
    res.status(500).json({ error: "Server error" });
});

// ⚠️ CONFIGURE: Server port
const PORT = process.env.PORT || 3000;

// Export loggers so they can be used in other modules
module.exports = {
  logger,
  orderLogger,
  paymentLogger,
  adminLogger,
  systemLogger
};

// CRITICAL: Create server this way to handle shutdown
const server = app.listen(PORT, () => {
    systemLogger.info(`Server started on port ${PORT}`);
    paymentLogger.info(`Payment status checking service initialized`);
});

// Graceful Shutdown Handler
function gracefulShutdown() {
    systemLogger.info('Received kill signal, shutting down gracefully');
    
    // First close the server
    server.close(async () => {
        systemLogger.info('Closed out remaining connections');
        
        // Then close the payment status queue
        try {
            await paymentStatusQueue.close();
            paymentLogger.info('Payment status queue closed');
        } catch (err) {
            logger.error('Error closing payment status queue', { error: err.message });
        }
        
        process.exit(0);
    });
    
    // Force close after 10 seconds
    setTimeout(() => {
        logger.error('Could not close connections in time, forcefully shutting down');
        process.exit(1);
    }, 10000);
}

// Handle shutdown signals
process.on('SIGTERM', gracefulShutdown);
process.on('SIGINT', gracefulShutdown);

// Catch unhandled promise rejections
process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled Promise Rejection', { reason: reason.toString() });
});

// Catch uncaught exceptions
process.on('uncaughtException', (error) => {
  logger.error('Uncaught Exception', { error: error.toString(), stack: error.stack });
  // Give the logger time to log the error before exiting
  setTimeout(() => {
    process.exit(1);
  }, 1000);
});

// Add basic health check endpoint
app.get('/health', (req, res) => {
    const timestamp = new Date().toISOString();
    res.json({ status: 'ok', timestamp });
});----------------------------------------

=== File: /workspaces/mware3/.env ===
# Database Configuration
DATABASE_URL=postgres://postgres:********@localhost:5432/railway_dev

# Security
JWT_SECRET=**********************

# POLi Payment Integration
POLI_AUTH_CODE=**********************
POLI_API_URL=https://poliapi.uat3.paywithpoli.com/api/POLiLink/Create
POLI_API_STATUS_URL=https://publicapi.uat3.paywithpoli.com/api/POLiLink/Status/

# CORS Configuration
CORS_ORIGIN=https://gold-buyers-christchurch-test.webflow.io

# Database Connection Details (extracted from DATABASE_URL)
DB_HOST=localhost
DB_PORT=5432
DB_NAME=railway_dev
DB_USER=postgres
DB_PASSWORD=********

BLINK_CLIENT_ID=uJlIlsU0bLYc86N3zBpZZqpptgdlZ5sk
BLINK_CLIENT_SECRET=9XisL8Q0_89MUTyyTP0_AzbenEQ5fF7-8vgemVxrxmpO_5EOR8B4nEpH2if_5XWp

BLINK_API_BASE_URL=https://sandbox.debit.blinkpay.co.nz/payments/v1
BLINK_AUTH_URL=https://sandbox.debit.blinkpay.co.nz/oauth2/token
BLINK_REDIRECT_URL=https://gold-buyers-christchurch.webflow.io/

BLINK_PAYMENT_EXPIRY_MINUTES=30
REDIS_URL=redis://localhost:6379
CLEANUP_PAYMENT_STATUS_QUEUE=false


BTCPAY_API_URL=https://btcpay.canterburygold.co.nz
BTCPAY_API_KEY=93a2787029a386c85ef6f174e7bc71c211ee9d74
BTCPAY_STORE_ID=BBBSsTabQGXnK3FhJAHVrygBN1gFPC5tfeUWrPWRFZHP
BTCPAY_REDIRECT_URL=https://gold-buyers-christchurch.webflow.io/

STRIPE_BASE_URL=https://api.stripe.com
STRIPE_PUBLISHABLE_KEY=pk_test_51Qv6w4R50uNdu8Yp0pzgpGaetorJpmgYWqDGXztPkRbaBQ1zI3jh6OKAeITqCkr8aPqvuoP0JTuRcxYwb8kYXHWf00tP2l274h
STRIPE_SECRET_KEY=sk_test_51Qv6w4R50uNdu8Yp2nOjV2WWSmQgUgVklyvNhAjitxt9vQYRiMUUrrapfOx8rfA22Ysdv0i3q5yHmW6sACLcSTBa00NS0fPrIA
STRIPE_LOCAL_FEE=0.027
STRIPE_SUCCESS_URL=https://gold-buyers-christchurch.webflow.io/
STRIPE_CANCEL_URL=https://gold-buyers-christchurch.webflow.io/
STRIPE_ALIPAY_FEE=0.03

ADMIN_PASSWORD=********

----------------------------------------
-e 
=== File: /workspaces/mware3/src/routes/admin/dashboard.js
// src/routes/admin/dashboard.js
const express = require('express');
const router = express.Router();
const pool = require('../../config/database');
const basicAuth = require('express-basic-auth');
const fs = require('fs');
const path = require('path');
const { Parser } = require('json2csv');

// Authentication middleware
const adminAuth = basicAuth({
  users: { 
    'admin': process.env.ADMIN_PASSWORD || 'changeme'
  },
  challenge: true,
  realm: 'Payment Admin Dashboard'
});

// Admin dashboard route with authentication
router.get('/payments', adminAuth, async (req, res) => {
  try {
    // Pagination parameters
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 50;
    const offset = (page - 1) * limit;
    
    // Search/filter parameters
    const search = req.query.search || '';
    const searchTO = req.query.searchTO || '';
    const provider = req.query.provider || '';
    
    // Get status filters from query params - both types of status
    const statusPayFilter = Array.isArray(req.query.statusPayFilter) 
      ? req.query.statusPayFilter 
      : req.query.statusPayFilter ? [req.query.statusPayFilter] : [];
      
    const statusUrlFilter = Array.isArray(req.query.statusUrlFilter) 
      ? req.query.statusUrlFilter 
      : req.query.statusUrlFilter ? [req.query.statusUrlFilter] : [];
    
    // Additional status filters for expired, unused and reviewed
    const showExpired = req.query.showExpired === 'on';
    const showUnused = req.query.showUnused === 'on';
    const reviewedFilter = req.query.reviewedFilter || 'all'; // 'all', 'yes', 'no'
    
    // Build query with filters
    let query = `
      SELECT p.*, o.trade_order, o.first_name_order, o.last_name_order, o.email_order, o.phone_order
      FROM payments p
      LEFT JOIN orders o ON p.order_record_id = o.record_id
      WHERE 1=1
    `;
    const params = [];
    
    // Regular search (email, phone)
    if (search) {
      params.push(`%${search}%`);
      params.push(`%${search}%`);
      query += ` AND (o.email_order ILIKE $${params.length-1} OR o.phone_order ILIKE $${params.length})`;
    }
    
    // Specific TO search
    if (searchTO) {
      params.push(`%${searchTO}%`);
      query += ` AND o.trade_order ILIKE $${params.length}`;
    }
    
    // Apply status_pay filters if provided
    if (statusPayFilter.length > 0) {
      const statusPlaceholders = statusPayFilter.map((_, index) => `$${params.length + index + 1}`).join(',');
      query += ` AND p.status_pay IN (${statusPlaceholders})`;
      params.push(...statusPayFilter);
    }
    
    // Apply status_url filters if provided
    if (statusUrlFilter.length > 0) {
      const urlStatusPlaceholders = statusUrlFilter.map((_, index) => `$${params.length + index + 1}`).join(',');
      query += ` AND p.status_url IN (${urlStatusPlaceholders})`;
      params.push(...statusUrlFilter);
    }
    
    if (provider) {
      params.push(provider);
      query += ` AND p.provider = $${params.length}`;
    }
    
    // Add expiry filter
    if (showExpired) {
      query += ` AND (p.expires_at < NOW() OR p.status_expiry = 'expired')`;
    }
    
    // Add unused filter (no status or pending status with no expiry)
    if (showUnused) {
      query += ` AND (p.status_pay IS NULL OR (p.status_pay = 'pending' AND p.status_expiry IS NULL))`;
    }
    
    // Add reviewed filter
    if (reviewedFilter === 'yes') {
      query += ` AND (p.reviewed = 'yes' OR p.reviewed = 'Yes')`;
    } else if (reviewedFilter === 'no') {
      query += ` AND (p.reviewed IS NULL OR p.reviewed = 'no' OR p.reviewed = 'No')`;
    }
    
    // Add sorting and pagination
    query += ` ORDER BY p.created_at DESC LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
    params.push(limit, offset);
    
    // Count total for pagination
    const countQuery = query.replace('SELECT p.*, o.trade_order, o.first_name_order, o.last_name_order, o.email_order, o.phone_order', 'SELECT COUNT(*)').split('ORDER BY')[0];
    
    // Execute queries
    console.log('Executing queries...');
    
    const [payments, countResult] = await Promise.all([
      pool.query(query, params),
      pool.query(countQuery, params.slice(0, -2))
    ]);
    
    const totalPayments = parseInt(countResult.rows[0].count);
    const totalPages = Math.ceil(totalPayments / limit);
    
    console.log(`Found ${payments.rows.length} payments of ${totalPayments} total`);
    
    // Render the admin dashboard with data
    res.render('admin/payments', {
      payments: payments.rows,
      page,
      limit,
      totalPages,
      totalPayments,
      search,
      searchTO,
      statusPayFilter,
      statusUrlFilter,
      provider,
      showExpired,
      showUnused,
      reviewedFilter
    });
  } catch (error) {
    console.error('Error fetching payments for admin dashboard:', error);
    res.status(500).render('admin/error', { error: 'Failed to load payment data: ' + error.message });
  }
});

// Export CSV data route
router.get('/export-csv', adminAuth, async (req, res) => {
  try {
    const startDate = req.query.startDate || '';
    const endDate = req.query.endDate || '';
    
    // Validate dates
    if (!startDate || !endDate) {
      return res.status(400).json({ 
        success: false, 
        error: 'Start date and end date are required' 
      });
    }
    
    // Build query with date range
    const query = `
      SELECT 
        p.record_id AS payment_id,
        p.created_at AS payment_date,
        p.provider,
        p.amount,
        p.status_pay,
        p.status_url,
        p.reviewed,
        p.status_expiry,
        p.expires_at,
        p.payment_url,
        p.payid,
        o.record_id AS order_id,
        o.trade_order,
        o.first_name_order,
        o.last_name_order,
        o.email_order,
        o.phone_order,
        o.product_name_full,
        o.total_price,
        o.quantity,
        o.price_nzd,
        o.address,
        o.message,
        o.order_creation_time
      FROM payments p
      LEFT JOIN orders o ON p.order_record_id = o.record_id
      WHERE p.created_at BETWEEN $1 AND $2
      ORDER BY p.created_at DESC
    `;
    
    // Execute the query with the date range
    const formattedStartDate = new Date(startDate);
    const formattedEndDate = new Date(endDate);
    formattedEndDate.setHours(23, 59, 59, 999); // Set to end of day
    
    const result = await pool.query(query, [formattedStartDate, formattedEndDate]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: 'No data found for the selected date range'
      });
    }
    
    // Setup CSV fields
    const fields = [
      { label: 'Payment ID', value: 'payment_id' },
      { label: 'Payment Date', value: row => new Date(row.payment_date).toLocaleString() },
      { label: 'Provider', value: 'provider' },
      { label: 'Amount', value: 'amount' },
      { label: 'Payment Status', value: 'status_pay' },
      { label: 'URL Status', value: 'status_url' },
      { label: 'Reviewed', value: 'reviewed' },
      { label: 'Expiry Status', value: 'status_expiry' },
      { label: 'Order ID', value: 'order_id' },
      { label: 'Order Number', value: 'trade_order' },
      { label: 'First Name', value: 'first_name_order' },
      { label: 'Last Name', value: 'last_name_order' },
      { label: 'Email', value: 'email_order' },
      { label: 'Phone', value: 'phone_order' },
      { label: 'Product', value: 'product_name_full' },
      { label: 'Quantity', value: 'quantity' },
      { label: 'Order Total', value: 'total_price' },
      { label: 'Address', value: 'address' },
      { label: 'Message', value: 'message' },
      { label: 'Order Date', value: row => row.order_creation_time ? new Date(row.order_creation_time).toLocaleString() : '' },
      { label: 'Payment URL', value: 'payment_url' }
    ];
    
    // Generate CSV
    const json2csv = new Parser({ fields });
    const csv = json2csv.parse(result.rows);
    
    // Set headers for file download
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename=payments_${startDate}_to_${endDate}.csv`);
    
    // Send the CSV data
    res.send(csv);
  } catch (error) {
    console.error('Error exporting CSV:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to export data: ' + error.message 
    });
  }
});

// Order details view - fixed to handle both numeric IDs and "TO-xxxx" format
router.get('/order/:orderId', adminAuth, async (req, res) => {
  try {
    const orderId = req.params.orderId;
    let orderResult;
    
    if (orderId.startsWith('TO-')) {
      // If it's a TO-xxxx format, search by trade_order
      orderResult = await pool.query(
        `SELECT * FROM orders WHERE trade_order = $1`, 
        [orderId]
      );
    } else {
      // Otherwise assume it's a numeric record_id
      const recordId = parseInt(orderId, 10);
      if (isNaN(recordId)) {
        return res.status(400).render('admin/error', { error: 'Invalid order ID format' });
      }
      
      orderResult = await pool.query(
        `SELECT * FROM orders WHERE record_id = $1`, 
        [recordId]
      );
    }
    
    if (orderResult.rows.length === 0) {
      return res.status(404).render('admin/error', { error: 'Order not found' });
    }
    
    // Get payments for this order
    const paymentResult = await pool.query(
      `SELECT * FROM payments WHERE order_record_id = $1 ORDER BY created_at DESC`,
      [orderResult.rows[0].record_id]
    );
    
    res.render('admin/order-details', {
      order: orderResult.rows[0],
      payments: paymentResult.rows
    });
  } catch (error) {
    console.error('Error fetching order details:', error);
    res.status(500).render('admin/error', { error: 'Failed to load order details: ' + error.message });
  }
});

// API endpoint to mark payment as reviewed
router.post('/api/mark-reviewed/:paymentId', adminAuth, async (req, res) => {
  try {
    const paymentId = req.params.paymentId;
    
    console.log(`Marking payment ID ${paymentId} as reviewed`);
    
    // Update the reviewed column
    await pool.query(
      `UPDATE payments SET reviewed = 'yes' WHERE record_id = $1`, 
      [paymentId]
    );
    
    res.json({
      success: true,
      message: 'Payment marked as reviewed'
    });
  } catch (error) {
    console.error('Error marking payment as reviewed:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// API endpoint for AJAX data refresh
router.get('/payments/data', adminAuth, async (req, res) => {
  try {
    // Check if we're requesting a single payment
    const singlePaymentId = req.query.singlePaymentId ? parseInt(req.query.singlePaymentId) : null;
    
    // If we're requesting a single payment by ID
    if (singlePaymentId) {
      const result = await pool.query(
        `SELECT p.*, o.trade_order, o.first_name_order, o.last_name_order, o.email_order, o.phone_order
         FROM payments p
         LEFT JOIN orders o ON p.order_record_id = o.record_id
         WHERE p.record_id = $1`,
        [singlePaymentId]
      );
      
      return res.json({
        success: true,
        payments: result.rows
      });
    }
    
    // Regular data refresh
    const limit = parseInt(req.query.limit) || 50;
    const search = req.query.search || '';
    const searchTO = req.query.searchTO || '';
    const provider = req.query.provider || '';
    
    // Get status filters from query params - both types of status
    const statusPayFilter = Array.isArray(req.query.statusPayFilter) 
      ? req.query.statusPayFilter 
      : req.query.statusPayFilter ? [req.query.statusPayFilter] : [];
      
    const statusUrlFilter = Array.isArray(req.query.statusUrlFilter) 
      ? req.query.statusUrlFilter 
      : req.query.statusUrlFilter ? [req.query.statusUrlFilter] : [];
    
    // Additional status filters for expired, unused and reviewed
    const showExpired = req.query.showExpired === 'on';
    const showUnused = req.query.showUnused === 'on';
    const reviewedFilter = req.query.reviewedFilter || 'all';
    
    // Query for the latest payments matching filters
    let query = `
      SELECT p.*, o.trade_order, o.first_name_order, o.last_name_order, o.email_order, o.phone_order
      FROM payments p
      LEFT JOIN orders o ON p.order_record_id = o.record_id
      WHERE 1=1
    `;
    const params = [];
    
    // Regular search (email, phone)
    if (search) {
      params.push(`%${search}%`);
      params.push(`%${search}%`);
      query += ` AND (o.email_order ILIKE $${params.length-1} OR o.phone_order ILIKE $${params.length})`;
    }
    
    // Specific TO search
    if (searchTO) {
      params.push(`%${searchTO}%`);
      query += ` AND o.trade_order ILIKE $${params.length}`;
    }
    
    // Apply status_pay filters if provided
    if (statusPayFilter.length > 0) {
      const statusPlaceholders = statusPayFilter.map((_, index) => `$${params.length + index + 1}`).join(',');
      query += ` AND p.status_pay IN (${statusPlaceholders})`;
      params.push(...statusPayFilter);
    }
    
    // Apply status_url filters if provided
    if (statusUrlFilter.length > 0) {
      const urlStatusPlaceholders = statusUrlFilter.map((_, index) => `$${params.length + index + 1}`).join(',');
      query += ` AND p.status_url IN (${urlStatusPlaceholders})`;
      params.push(...statusUrlFilter);
    }
    
    if (provider) {
      params.push(provider);
      query += ` AND p.provider = $${params.length}`;
    }
    
    // Add expiry filter
    if (showExpired) {
      query += ` AND (p.expires_at < NOW() OR p.status_expiry = 'expired')`;
    }
    
    // Add unused filter
    if (showUnused) {
      query += ` AND (p.status_pay IS NULL OR (p.status_pay = 'pending' AND p.status_expiry IS NULL))`;
    }
    
    // Add reviewed filter
    if (reviewedFilter === 'yes') {
      query += ` AND (p.reviewed = 'yes' OR p.reviewed = 'Yes')`;
    } else if (reviewedFilter === 'no') {
      query += ` AND (p.reviewed IS NULL OR p.reviewed = 'no' OR p.reviewed = 'No')`;
    }
    
    query += ` ORDER BY p.created_at DESC LIMIT $${params.length + 1}`;
    params.push(limit);
    
    const result = await pool.query(query, params);
    
    res.json({
      success: true,
      payments: result.rows
    });
  } catch (error) {
    console.error('Error fetching payments data:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

module.exports = router;----------------------------------------
-e 
=== File: /workspaces/mware3/src/routes/public/orders.js
/**
 * Order Routes
 * -----------
 * Purpose: Defines all HTTP endpoints related to orders
 * Role: Handles HTTP requests and delegates business logic to OrderService
 * 
 * Current Endpoints:
 * POST /create - Creates a new order
 * 
 * Dependencies:
 * - OrderService for business logic
 * - Express Router for routing
 * 
 * Error Handling:
 * - 400 for validation errors
 * - 500 for server errors
 */

const express = require('express');
const router = express.Router();
const OrderService = require('../../services/orders/orderService');

router.post("/create", async (req, res) => {
    try {
        const result = await OrderService.createOrder(req.body);
        res.json(result);
    } catch (error) {
        console.error("Order creation error:", error);
        res.status(error.message.includes("required") ? 400 : 500)
           .json({ error: error.message || "Failed to create order" });
    }
});

module.exports = router;----------------------------------------
-e 
=== File: /workspaces/mware3/src/routes/public/payments.js
/**
 * Payment Routes
 * -------------
 * Purpose: Handles payment status checking endpoints
 * Role: Provides API for checking payment URL status
 * 
 * Endpoints:
 * GET /api/payment-status/:token - Check payment URL status
 * GET /api/check-payment-status/:paymentId - Manually check specific payment status
 * 
 * Dependencies:
 * - PaymentService for business logic
 * - PaymentStatusService for status checks
 * - Express Router for routing
 * 
 * Error Handling:
 * - 400 for validation errors
 * - 500 for server errors
 */

const express = require('express');
const router = express.Router();
const PaymentService = require('../../services/payments/paymentService');
const paymentStatusService = require('../../services/payments/paystatus/paymentStatusService');
const rateLimit = require('express-rate-limit');

// Rate limiting: 60 requests per minute
const statusLimiter = rateLimit({
    windowMs: 60 * 1000,
    max: 60,
    message: { error: 'Too many requests, please try again later' }
});

router.get("/payment-status/:token", statusLimiter, async (req, res) => {
    try {
        console.log(`Checking payment status for token: ${req.params.token}`);
        const result = await PaymentService.getStatusByToken(req.params.token);
        res.json(result);
    } catch (error) {
        console.error("Payment status check error:", error);
        res.status(400).json({ 
            error: error.message || "Failed to check payment status" 
        });
    }
});

// New route for manually checking payment status
router.get("/check-payment-status/:paymentId", statusLimiter, async (req, res) => {
    try {
        console.log(`Manually checking payment status for ID: ${req.params.paymentId}`);
        const result = await paymentStatusService.checkPaymentStatus(req.params.paymentId);
        res.json(result);
    } catch (error) {
        console.error("Manual payment status check error:", error);
        res.status(400).json({ 
            error: error.message || "Failed to check payment status" 
        });
    }
});

module.exports = router;----------------------------------------
-e 
=== File: /workspaces/mware3/src/config/cors.js
/**
 * CORS Configuration
 * -----------------
 * Purpose: Defines Cross-Origin Resource Sharing (CORS) settings
 * Role: Controls which domains can access your API
 * 
 * IMPORTANT CONFIGURATION:
 * - origin: Change this URL when deploying to different environments
 * - methods: HTTP methods allowed
 * - allowedHeaders: Headers clients can send
 */

const corsOptions = {
    origin: process.env.CORS_ORIGIN,
    methods: "GET,POST,OPTIONS",
    allowedHeaders: "Content-Type",
    credentials: true
};

module.exports = corsOptions;----------------------------------------
-e 
=== File: /workspaces/mware3/src/config/database.js
/**
 * Database Configuration
 * ---------------------
 * Purpose: Centralizes database connection configuration
 * Role: Provides a single connection pool instance used throughout the application
 * 
 * Dependencies:
 * - pg (PostgreSQL client)
 * - DATABASE_URL environment variable
 * 
 * IMPORTANT CONFIGURATION:
 * The DATABASE_URL should be set in your .env file with format:
 * postgresql://username:password@host:port/database
 */

const { Pool } = require("pg");

const pool = new Pool({ 
    connectionString: process.env.DATABASE_URL 
});

module.exports = pool;----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/pdf/pdfService.js
/**
 * PDF Generation Service
 * ---------------------
 * Purpose: Handles PDF generation for order confirmations
 * Role: Creates PDFs from order data using Puppeteer
 * 
 * Dependencies:
 * - puppeteer for PDF generation
 * - Requires Chrome/Chromium to be installed in the environment
 */

const puppeteer = require('puppeteer');

class PDFService {
    async generateOrderPDF(orderData) {
        const browser = await puppeteer.launch({
            args: ['--no-sandbox', '--disable-setuid-sandbox'],
            headless: 'new'  // Using new headless mode
        });

        try {
            const page = await browser.newPage();
            
            // TODO: Replace with your actual order page URL
            // await page.goto('https://your-webflow-print-page-url');
            
            // TODO: Add logic to populate order data
            
            const pdf = await page.pdf({
                format: 'A4',
                printBackground: true
            });

            return pdf;
        } finally {
            await browser.close();
        }
    }
}

module.exports = new PDFService();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/poliService.js
/**
 * POLi Payment Service Integration
 * 
 * This service handles the integration with POLi payment gateway for processing payments
 * in New Zealand. It provides functionality to generate payment links and handle payment
 * transactions through the POLi API.
 * 
 * Key Features:
 * - Generates payment links with 30-minute expiry
 * - Handles NZ timezone specific formatting
 * - Stores payment records in database
 * - Error handling and logging
 * - Extracts and stores payment token for status checking
 * - Schedules status checks at 1min and 3min (for testing)
 * 
 * Flow:
 * 1. Receives order data
 * 2. Generates expiry timestamp in NZ timezone
 * 3. Creates POLi API payload
 * 4. Makes API request to generate payment link
 * 5. Extracts payment token from URL
 * 6. Stores payment record with token in database
 * 7. Schedules status checks
 * 
 * Requirements:
 * - POLi API credentials in environment variables
 * - PostgreSQL database connection
 * - Axios for HTTP requests
 */

const axios = require('axios');
const pool = require('../../config/database');
const { schedulePaymentStatusChecks } = require('./paystatus/paymentStatusQueue');

class PoliService {
    /**
     * Generates a payment link through POLi API
     * @param {Object} orderData - Contains order details including total_price and trade_order
     * @returns {String} Payment URL for redirect
     */
    async generatePaymentLink(orderData) {
        try {
            console.log('\n=== POLi Payment Processing ===');
            console.log('Generating POLi payment link for order:', orderData.trade_order);

            // Calculate expiry time 30 minutes from now
            const date = new Date();
            const futureDate = new Date(date.getTime() + (30 * 60 * 1000));
            
            // Format with New Zealand timezone (UTC+13)
            const formattedExpiry = futureDate.toLocaleString('en-NZ', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                timeZone: 'Pacific/Auckland',
                hour12: false
            }).replace(/(\d{2})\/(\d{2})\/(\d{4}), (\d{2}):(\d{2}):(\d{2})/, '$3-$2-$1T$4:$5:$6+13:00');

            console.log('POLi Generated Expiry Time:', formattedExpiry);

            // Construct payload for POLi API
            const payload = {
                LinkType: "0",
                Amount: orderData.total_price.toString(),
                MerchantReference: orderData.trade_order,
                LinkExpiry: formattedExpiry
            };

            console.log('POLi API Payload:', JSON.stringify(payload));

            // Make API request to POLi
            const response = await axios.post(
                process.env.POLI_API_URL,
                payload,
                {
                    headers: {
                        'Authorization': `Basic ${process.env.POLI_AUTH_CODE}`,
                        'Content-Type': 'application/json'
                    }
                }
            );

            // Process response and remove quotes
            const paymentUrl = response.data.replace(/"/g, '');
            console.log('POLi API Response:', paymentUrl);

            // Extract the token from the URL
            // URL format example: https://poliapi.uat3.paywithpoli.com/api/POLiLink/Navigate/wsWnx
            const payidMatch = paymentUrl.match(/\/([^\/]+)$/);
            const payid = payidMatch ? payidMatch[1] : null;

            console.log('Extracted POLi token (payid):', payid);

            // Store successful payment record in database with payid
            const result = await pool.query(
                `INSERT INTO payments (order_record_id, provider, status_url, amount, payment_url, payid) 
                 VALUES ($1, $2, $3, $4, $5, $6)
                 RETURNING record_id`,
                [orderData.record_id, 'POLi', 'success', orderData.total_price, paymentUrl, payid]
            );
            
            const paymentRecordId = result.rows[0]?.record_id;

            // Schedule status checks at 1min and 3min after creation (for testing)
            if (payid && paymentRecordId) {
                schedulePaymentStatusChecks({
                    record_id: paymentRecordId,
                    provider: 'POLi',
                    payid: payid
                });
            }

            return paymentUrl;

        } catch (error) {
            console.error('\n=== POLi API Error ===');
            console.error('Error details:', {
                message: error.message,
                response: error.response?.data,
                order: orderData.trade_order
            });
            
            // Store failed payment record in database
            await pool.query(
                `INSERT INTO payments (order_record_id, provider, status_url, amount, message_url) 
                 VALUES ($1, $2, $3, $4, $5)`,
                [orderData.record_id, 'POLi', 'failed', orderData.total_price, 
                 error.response?.data?.ErrorMessage || error.message]
            );
            throw error;
        }
    }
}

module.exports = new PoliService();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/stripeService.js
/**
 * Stripe Payment Service Integration
 * --------------------------------
 * Purpose: Handles Stripe Checkout Session creation for payment processing
 * 
 * Features:
 * - Creates one-time payment links using Stripe Checkout
 * - Supports single payments without inventory management
 * - 30-minute expiry on payment links
 * - Calculates fees (2.7% + $0.30)
 * - New Zealand specific restrictions
 * 
 * Required Environment Variables:
 * - STRIPE_SECRET_KEY: Stripe API secret key
 * - STRIPE_BASE_URL: Base URL for Stripe API
 * - STRIPE_LOCAL_FEE: Local fee percentage (e.g., 0.027 for 2.7%)
 * - STRIPE_SUCCESS_URL: Success redirect URL
 * - STRIPE_CANCEL_URL: Cancel redirect URL
 */

const axios = require('axios');
const pool = require('../../config/database');
const { schedulePaymentStatusChecks } = require('./paystatus/paymentStatusQueue');

class StripeService {
    constructor() {
        this.secretKey = process.env.STRIPE_SECRET_KEY;
        this.baseUrl = process.env.STRIPE_BASE_URL;
        this.feePercentage = parseFloat(process.env.STRIPE_LOCAL_FEE) || 0.027;
        this.fixedFee = 0.30; // Fixed fee in dollars
        this.successUrl = process.env.STRIPE_SUCCESS_URL;
        this.cancelUrl = process.env.STRIPE_CANCEL_URL;

        // Validate configuration
        const requiredEnvVars = [
            'STRIPE_SECRET_KEY',
            'STRIPE_BASE_URL',
            'STRIPE_SUCCESS_URL',
            'STRIPE_CANCEL_URL'
        ];

        const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);
        if (missingVars.length > 0) {
            console.warn('Missing Stripe configuration:', missingVars.join(', '));
        }
    }

    /**
     * Calculates total amount including Stripe fees
     * Formula: (base amount + 0.30) / (1 - 0.027)
     * @param {number} baseAmount - Original amount before fees
     * @returns {number} Total amount including fees
     */
    calculateTotalWithFees(baseAmount) {
        const amount = parseFloat(baseAmount);
        return (amount + this.fixedFee) / (1 - this.feePercentage);
    }

    /**
     * Generates a Stripe Checkout Session payment link
     * @param {Object} orderData - Order information including amount and reference
     * @returns {String} Checkout session URL
     */
    async generatePaymentLink(orderData) {
        try {
            console.log('\n=== Stripe Payment Processing ===');
            console.log('Generating Stripe payment link for order:', orderData.trade_order);

            // Calculate total amount including fees
            const baseAmount = parseFloat(orderData.total_price);
            const totalWithFees = this.calculateTotalWithFees(baseAmount);
            
            // Convert to cents for Stripe
            const amountInCents = Math.round(totalWithFees * 100);

            console.log('Payment calculation:', {
                baseAmount,
                feePercentage: this.feePercentage,
                fixedFee: this.fixedFee,
                totalWithFees,
                amountInCents
            });

            const payload = {
                mode: 'payment',
                success_url: this.successUrl,
                cancel_url: this.cancelUrl,
                currency: 'nzd',
                payment_method_types: ['card'],
                
                billing_address_collection: 'required',
                shipping_address_collection: {
                    allowed_countries: ['NZ']
                },

                line_items: [{
                    price_data: {
                        currency: 'nzd',
                        product_data: {
                            name: orderData.product_name_full || 'Gold Purchase',
                            description: `Order: ${orderData.trade_order} (Includes processing fee)`
                        },
                        unit_amount: amountInCents
                    },
                    quantity: 1
                }],

                customer_email: orderData.email_order || undefined,
                client_reference_id: orderData.trade_order,
                expires_at: Math.floor(Date.now() / 1000) + (30 * 60)
            };

            const response = await axios.post(
                `${this.baseUrl}/v1/checkout/sessions`,
                payload,
                {
                    headers: {
                        'Authorization': `Bearer ${this.secretKey}`,
                        'Content-Type': 'application/x-www-form-urlencoded'
                    }
                }
            );

            console.log('Stripe Checkout Session created:', response.data.id);

            if (response.data && response.data.url) {
                // Store payment record with original amount (not including fees)
                const insertResult = await pool.query(
                    `INSERT INTO payments (
                        order_record_id, provider, status_url, amount, 
                        payment_url, payid, expires_at
                    ) VALUES ($1, $2, $3, $4, $5, $6, NOW() + interval '30 minutes')
                    RETURNING record_id`,
                    [
                        orderData.record_id,
                        'STRIPE',
                        'success',
                        orderData.total_price, // Store original amount
                        response.data.url,
                        response.data.id
                    ]
                );
                
                // Schedule status checks at 1min and 3min after creation (for testing)
                schedulePaymentStatusChecks({
                    record_id: insertResult.rows[0].record_id,
                    provider: 'STRIPE',
                    payid: response.data.id
                });

                return response.data.url;
            } else {
                throw new Error('Invalid response from Stripe');
            }

        } catch (error) {
            console.error('\n=== Stripe API Error ===');
            console.error('Error details:', {
                message: error.message,
                response: error.response?.data,
                order: orderData.trade_order
            });

            // Store failed payment record
            await pool.query(
                `INSERT INTO payments (
                    order_record_id, provider, status_url, amount, message_url
                ) VALUES ($1, $2, $3, $4, $5)`,
                [
                    orderData.record_id,
                    'STRIPE',
                    'failed',
                    orderData.total_price,
                    error.response?.data?.error?.message || error.message
                ]
            );

            throw error;
        }
    }
}

module.exports = new StripeService();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/paystatus/providers/alipayPaymentStatus.js
/**
 * Alipay Payment Status Provider
 * ----------------------------
 * Purpose: Handles Alipay-specific payment status checking
 * 
 * Functions:
 * - Connect to Stripe API (which handles Alipay)
 * - Query Checkout Session status using the stored session ID
 * - Return raw API responses without any normalization
 */

const axios = require('axios');

class AlipayPaymentStatus {
    constructor() {
        this.baseUrl = process.env.STRIPE_BASE_URL || 'https://api.stripe.com';
        this.secretKey = process.env.STRIPE_SECRET_KEY;
    }

    /**
     * Check the status of an Alipay payment
     * @param {string} sessionId - The Checkout Session ID to check
     * @returns {Object} Raw status information from Stripe API
     */
    async checkStatus(sessionId) {
        try {
            console.log(`Checking Alipay payment status for session: ${sessionId}`);
            
            // Make API request to Stripe (which powers Alipay payments)
            const response = await axios.get(
                `${this.baseUrl}/v1/checkout/sessions/${sessionId}`,
                {
                    headers: {
                        'Authorization': `Bearer ${this.secretKey}`,
                        'Content-Type': 'application/json'
                    }
                }
            );
            
            console.log(`Alipay status response for ${sessionId}:`, response.data);
            
            // Check if payment method types include alipay
            const isAlipayPayment = response.data.payment_method_types &&
                                   response.data.payment_method_types.includes('alipay');
            
            if (!isAlipayPayment) {
                console.warn(`Session ${sessionId} does not appear to be an Alipay payment`);
            }
            
            return {
                // Raw status from API
                status: response.data.payment_status || 'unknown',
                originalStatus: `${response.data.status}/${response.data.payment_status}`,
                message: `Alipay status check successful: ${response.data.payment_status}`
            };
        } catch (error) {
            console.error(`Alipay status check error for ${sessionId}:`, {
                message: error.message,
                response: error.response?.data || error.response?.statusText
            });
            
            return {
                status: 'error',
                originalStatus: error.response?.status || 'unknown',
                message: error.response?.data?.error?.message || error.message
            };
        }
    }
}

module.exports = new AlipayPaymentStatus();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/paystatus/providers/blinkPaymentStatus.js
/**
 * Blink Payment Status Provider
 * ----------------------------
 * Purpose: Handles Blink-specific payment status checking
 * 
 * Functions:
 * - Connect to Blink API with proper authentication
 * - Query payment status using the stored quick_payment_id
 * - Return raw API responses without any normalization
 * - Maps payment status to pay_status.status and consent status to payments.status_url
 */

const axios = require('axios');

class BlinkPaymentStatus {
    constructor() {
        this.baseUrl = process.env.BLINK_API_BASE_URL;
        this.clientId = process.env.BLINK_CLIENT_ID;
        this.clientSecret = process.env.BLINK_CLIENT_SECRET;
        this.authUrl = process.env.BLINK_AUTH_URL;
        
        // Token management
        this.accessToken = null;
        this.tokenExpiry = null;
    }

    /**
     * Get an access token for Blink API
     * @returns {string} Access token
     */
    async getAccessToken() {
        try {
            console.log('Requesting Blink access token for status check...');
            
            const payload = {
                client_id: this.clientId,
                client_secret: this.clientSecret,
                grant_type: 'client_credentials',
                audience: 'https://api.blinkdebit.co.nz'
            };

            const response = await axios.post(
                this.authUrl,
                payload,
                {
                    headers: {
                        'Content-Type': 'application/json'
                    }
                }
            );

            this.accessToken = response.data.access_token;
            this.tokenExpiry = Date.now() + (response.data.expires_in * 1000);
            
            console.log('Successfully obtained Blink access token for status check');
            return this.accessToken;
        } catch (error) {
            console.error('Failed to get Blink access token:', error.response?.data || error.message);
            throw error;
        }
    }

    /**
     * Ensure we have a valid token
     * @returns {string} Valid access token
     */
    async ensureValidToken() {
        if (!this.accessToken || !this.tokenExpiry || Date.now() >= this.tokenExpiry - 60000) {
            await this.getAccessToken();
        }
        return this.accessToken;
    }

    /**
     * Check the status of a Blink payment
     * @param {string} quickPaymentId - The Blink quick_payment_id to check
     * @returns {Object} Raw status information from Blink API
     */
    async checkStatus(quickPaymentId) {
        try {
            console.log(`Checking Blink payment status for quick_payment_id: ${quickPaymentId}`);
            
            // Ensure we have a valid token
            const token = await this.ensureValidToken();
            
            // Make API request to Blink
            const response = await axios.get(
                `${this.baseUrl}/quick-payments/${quickPaymentId}`,
                {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    }
                }
            );
            
            console.log(`Blink status response for ${quickPaymentId}:`, response.data);
            
            // Extract the payment status and consent status from the response
            const paymentStatus = response.data.consent?.payments?.[0]?.status || 'unknown';
            const consentStatus = response.data.consent?.status || 'unknown';
            
            return {
                // Consent status only for updating payments.status_url
                status: consentStatus,
                // Payment status only for inserting into pay_status.status
                payment_status: paymentStatus,
                originalStatus: `Consent: ${consentStatus} / Payment: ${paymentStatus}`,
                message: `Blink status check successful: Consent: ${consentStatus}, Payment: ${paymentStatus}`
            };
        } catch (error) {
            console.error(`Blink status check error for ${quickPaymentId}:`, {
                message: error.message,
                response: error.response?.data || error.response?.statusText
            });
            
            // If 404 error, payment may have been deleted or expired
            if (error.response?.status === 404) {
                return {
                    status: 'expired',
                    payment_status: 'expired',
                    originalStatus: 'expired',
                    message: 'Payment link has expired or been deleted'
                };
            }
            
            return {
                status: 'error',
                payment_status: 'error',
                originalStatus: error.response?.status || 'unknown',
                message: error.response?.data?.title || error.message
            };
        }
    }
}

module.exports = new BlinkPaymentStatus();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/paystatus/providers/btcpayPaymentStatus.js
/**
 * BTCPay Server Payment Status Provider
 * -----------------------------------
 * Purpose: Handles BTCPay-specific payment status checking
 * 
 * Functions:
 * - Connect to BTCPay Server API with proper authentication
 * - Query invoice status using the stored invoice ID
 * - Parse and normalize API responses
 * - Handle BTCPay-specific error conditions
 */

const axios = require('axios');

class BTCPayPaymentStatus {
    constructor() {
        // Remove trailing slash if present in API URL
        this.baseUrl = process.env.BTCPAY_API_URL?.replace(/\/$/, '');
        this.apiKey = process.env.BTCPAY_API_KEY;
        this.storeId = process.env.BTCPAY_STORE_ID;
    }

    /**
     * Check the status of a BTCPay invoice
     * @param {string} invoiceId - The BTCPay invoice ID to check
     * @returns {Object} Normalized status information
     */
    async checkStatus(invoiceId) {
        try {
            console.log(`Checking BTCPay invoice status for: ${invoiceId}`);
            
            if (!this.baseUrl || !this.apiKey || !this.storeId) {
                throw new Error('BTCPay configuration is incomplete');
            }
            
            // Make API request to BTCPay Server
            const response = await axios.get(
                `${this.baseUrl}/api/v1/stores/${this.storeId}/invoices/${invoiceId}`,
                {
                    headers: {
                        'Authorization': `token ${this.apiKey}`,
                        'Content-Type': 'application/json'
                    }
                }
            );
            
            console.log(`BTCPay status response for ${invoiceId}:`, {
                status: response.data.status,
                additionalStatus: response.data.additionalStatus
            });
            
            return {
                status: response.data.status || 'unknown',
                originalStatus: `${response.data.status}/${response.data.additionalStatus || 'none'}`,
                message: `BTCPay status check successful: ${response.data.status}`
            };
        } catch (error) {
            console.error(`BTCPay status check error for ${invoiceId}:`, {
                message: error.message,
                response: error.response?.data || error.response?.statusText
            });
            
            return {
                status: 'error',
                originalStatus: error.response?.status || 'unknown',
                message: error.response?.data?.message || error.message
            };
        }
    }
}

module.exports = new BTCPayPaymentStatus();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/paystatus/providers/poliPaymentStatus.js
/**
 * POLi Payment Status Provider
 * ----------------------------
 * Purpose: Handles POLi-specific payment status checking
 * 
 * Functions:
 * - Connect to POLi API with proper authentication
 * - Query payment status using the stored token/payid
 * - Return raw API responses without any normalization
 * - Provide raw status for both status_pay and status_url columns
 */

const axios = require('axios');

class PoliPaymentStatus {
    constructor() {
        // Use the environment variable for the base URL
        this.baseUrl = process.env.POLI_API_STATUS_URL || 'https://publicapi.uat3.paywithpoli.com/api/POLiLink/Status';
        this.authCode = process.env.POLI_AUTH_CODE;
    }

    /**
     * Check the status of a POLi payment
     * @param {string} payid - The payment token/ID to check
     * @returns {Object} Raw status information from POLi API
     */
    async checkStatus(payid) {
        try {
            console.log(`Checking POLi payment status for: ${payid}`);
            
            // Log URL being used (for debugging)
            const statusUrl = this.baseUrl.endsWith('/') ? `${this.baseUrl}${payid}` : `${this.baseUrl}/${payid}`;
            console.log(`POLi status check URL: ${statusUrl}`);
            console.log(`POLi auth code available: ${this.authCode ? 'Yes' : 'No'}`);
            
            // Make API request to POLi
            const response = await axios.get(statusUrl, {
                headers: {
                    'Authorization': `Basic ${this.authCode}`,
                    'Content-Type': 'application/json'
                }
            });
            
            console.log(`POLi status response for ${payid}:`, response.data);
            
            // POLi returns the status as a quoted string like "Activated" - remove quotes if needed
            const status = typeof response.data === 'string' 
                ? response.data.replace(/^"|"$/g, '') 
                : response.data;
            
            return {
                // Raw status for status_pay column
                status: status,
                // Same raw status for status_url column
                status_url: status,
                // For compatibility with existing code
                originalStatus: status,
                message: `POLi status check successful: ${status}`
            };
        } catch (error) {
            console.error(`POLi status check error for ${payid}:`, {
                message: error.message,
                response: error.response?.data || error.response?.statusText
            });
            
            return {
                status: 'error',
                status_url: 'error',
                originalStatus: error.response?.status || 'unknown',
                message: error.response?.data?.Message || error.message
            };
        }
    }
}

module.exports = new PoliPaymentStatus();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/paystatus/providers/stripePaymentStatus.js
/**
 * Stripe Payment Status Provider
 * ----------------------------
 * Purpose: Handles Stripe-specific payment status checking
 * 
 * Functions:
 * - Connect to Stripe API with proper authentication
 * - Query Checkout Session status using the stored session ID
 * - Parse and normalize API responses
 * - Handle Stripe-specific error conditions
 */

const axios = require('axios');

class StripePaymentStatus {
    constructor() {
        this.baseUrl = process.env.STRIPE_BASE_URL || 'https://api.stripe.com';
        this.secretKey = process.env.STRIPE_SECRET_KEY;
    }

    /**
     * Check the status of a Stripe payment
     * @param {string} sessionId - The Checkout Session ID to check
     * @returns {Object} Normalized status information
     */
    async checkStatus(sessionId) {
        try {
            console.log(`Checking Stripe payment status for session: ${sessionId}`);
            
            // Make API request to Stripe
            const response = await axios.get(
                `${this.baseUrl}/v1/checkout/sessions/${sessionId}`,
                {
                    headers: {
                        'Authorization': `Bearer ${this.secretKey}`,
                        'Content-Type': 'application/json'
                    }
                }
            );
            
            console.log(`Stripe status response for ${sessionId}:`, response.data);
            
            return {
                status: response.data.payment_status || 'unknown',
                originalStatus: `${response.data.status}/${response.data.payment_status}`,
                message: `Stripe status check successful: ${response.data.payment_status}`
            };
        } catch (error) {
            console.error(`Stripe status check error for ${sessionId}:`, {
                message: error.message,
                response: error.response?.data || error.response?.statusText
            });
            
            return {
                status: 'error',
                originalStatus: error.response?.status || 'unknown',
                message: error.response?.data?.error?.message || error.message
            };
        }
    }
}

module.exports = new StripePaymentStatus();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/paystatus/paymentStatusQueue.js
/**
 * Payment Status Queue
 * -------------------
 * Purpose: Manages scheduled jobs for payment status checks
 * 
 * Functions:
 * - Schedule status checks at 1min and 3min after each payment (for testing)
 * - Process jobs for different payment providers
 * - Handle job failures and retries
 */

const Queue = require('bull');
// Import the providers directly to avoid circular dependency
const poliPaymentStatus = require('./providers/poliPaymentStatus');
const stripePaymentStatus = require('./providers/stripePaymentStatus');
const alipayPaymentStatus = require('./providers/alipayPaymentStatus');
const btcpayPaymentStatus = require('./providers/btcpayPaymentStatus');
const blinkPaymentStatus = require('./providers/blinkPaymentStatus');
const pool = require('../../../config/database');

// Create the payment status check queue
const paymentStatusQueue = new Queue('payment-status-checks', process.env.REDIS_URL, {
    defaultJobOptions: {
        attempts: 3,
        backoff: {
            type: 'exponential',
            delay: 2000
        },
        removeOnComplete: true,
        removeOnFail: 100 // Keep the last 100 failed jobs for inspection
    }
});

// Process jobs for checking payment statuses
paymentStatusQueue.process(async (job) => {
    console.log(`Processing payment status check job: ${job.id}`, job.data);
    
    const { paymentId, payid, provider, checkTime } = job.data;
    
    // Validate required parameters to prevent errors
    if (!paymentId || !payid) {
        console.error(`Invalid job data - missing required parameters: ${JSON.stringify(job.data)}`);
        throw new Error('Missing required payment data (paymentId or payid)');
    }
    
    try {
        // Use provider directly to avoid circular dependency
        let statusResult;
        
        if (provider === 'POLi') {
            // Check payment status using the POLi provider
            statusResult = await poliPaymentStatus.checkStatus(payid);
        } 
        else if (provider === 'STRIPE') {
            // Check payment status using the Stripe provider
            statusResult = await stripePaymentStatus.checkStatus(payid);
        }
        else if (provider === 'ALIPAY') {
            // Check payment status using the Alipay provider
            statusResult = await alipayPaymentStatus.checkStatus(payid);
        }
        else if (provider === 'BTCPAY') {
            // Check payment status using the BTCPay provider
            statusResult = await btcpayPaymentStatus.checkStatus(payid);
        }
        else if (provider === 'BLINK') {
            // Check payment status using the Blink provider
            statusResult = await blinkPaymentStatus.checkStatus(payid);
        }
        else {
            throw new Error(`Unsupported provider: ${provider}`);
        }
        
        // Log the status check to database
        await logStatusCheck(paymentId, statusResult, statusResult.message);
        
        const result = {
            paymentId,
            payid,
            provider,
            status: statusResult.status,
            payment_status: statusResult.payment_status || statusResult.status,
            message: statusResult.message
        };
        
        console.log(`Completed ${checkTime} status check for ${provider} payment ${payid}`);
        return result;
    } catch (error) {
        console.error(`Error processing payment status check for ${provider} payment ${payid}:`, error);
        
        // Try to log the error
        try {
            await logStatusCheck(
                paymentId, 
                { status: 'error', payment_status: 'error' }, 
                error.message
            );
        } catch (logError) {
            console.error(`Failed to log status check error: ${logError.message}`);
        }
        
        throw error; // Rethrow to trigger Bull's retry mechanism
    }
});

/**
 * Helper function to log a status check to the database
 * Defined directly in this file to avoid circular dependencies
 */
async function logStatusCheck(paymentId, statusResult, message) {
    try {
        // For providers that return both status types (dual-status):
        // - payment_status goes to pay_status.status
        // - status goes to payments.status_url
        // For single-status providers, use the same value for both
        
        const paymentStatus = statusResult.payment_status || statusResult.status;
        
        // Insert into pay_status table
        const query = `
            INSERT INTO pay_status (payments_record_id, date_time, status, message)
            VALUES ($1, NOW(), $2, $3)
        `;
        
        await pool.query(query, [paymentId, paymentStatus, message]);
        console.log(`Logged status check for payment ${paymentId}: ${paymentStatus}`);
        
        // Update the main payment record status
        if (statusResult.status) {
            await pool.query(
                `UPDATE payments SET status_url = $1 WHERE record_id = $2`,
                [statusResult.status, paymentId]
            );
            console.log(`Updated payment record ${paymentId} with status: ${statusResult.status}`);
        }
    } catch (error) {
        console.error(`Error logging status check for payment ${paymentId}:`, error);
        throw error;
    }
}

/**
 * Schedule status checks for a specific payment
 * @param {Object} payment - Payment object with id, payid and provider
 */
function schedulePaymentStatusChecks(payment) {
    if (!payment || !payment.payid || !payment.record_id) {
        console.log('Cannot schedule status checks for payment - missing required data:', payment);
        return;
    }
    
    console.log(`Scheduling status checks for ${payment.provider} payment ${payment.payid}`);
    
    // Schedule first check at 1 minute after creation (for testing)
    paymentStatusQueue.add(
        {
            paymentId: payment.record_id,
            payid: payment.payid,
            provider: payment.provider,
            checkTime: '1min'
        },
        {
            delay: 1 * 60 * 1000, // 1 minute (for testing)
            jobId: `${payment.provider}-${payment.payid}-1min`
        }
    );
    
    // Schedule second check at 32 minutes after creation (for testing)
    paymentStatusQueue.add(
        {
            paymentId: payment.record_id,
            payid: payment.payid,
            provider: payment.provider,
            checkTime: '3min'
        },
        {
            delay: 32 * 60 * 1000, // 32 minutes (for testing)
            jobId: `${payment.provider}-${payment.payid}-32min`
        }
    );
    
    console.log(`Scheduled status checks for ${payment.provider} payment ${payment.payid} at +1min and +32min (testing)`);
}

// Event listeners for monitoring the queue
paymentStatusQueue.on('completed', (job, result) => {
    console.log(`Job ${job.id} completed:`, {
        provider: job.data.provider,
        payid: job.data.payid,
        status: result?.status || 'unknown',
        payment_status: result?.payment_status || result?.status || 'unknown'
    });
});

paymentStatusQueue.on('failed', (job, error) => {
    console.error(`Job ${job.id} failed:`, {
        provider: job.data.provider,
        payid: job.data.payid,
        error: error.message
    });
});

// Clean up any existing repeatable jobs from previous implementations
async function cleanupOldRepeatingJobs() {
    try {
        // Get all repeatable jobs
        const repeatableJobs = await paymentStatusQueue.getRepeatableJobs();
        
        // Remove all repeatable jobs
        for (const job of repeatableJobs) {
            await paymentStatusQueue.removeRepeatableByKey(job.key);
            console.log(`Removed old repeatable job: ${job.key}`);
        }
        
        console.log('Old repeatable jobs cleanup completed');
    } catch (error) {
        console.error('Error cleaning up old repeatable jobs:', error);
    }
}

// Only run cleanup if environment variable isn't set to false
if (process.env.CLEANUP_PAYMENT_STATUS_QUEUE !== 'false') {
    cleanupOldRepeatingJobs();
    console.log('Old repeatable jobs cleanup completed');
} else {
    console.log('Job cleanup skipped (CLEANUP_PAYMENT_STATUS_QUEUE=false)');
}

module.exports = {
    paymentStatusQueue,
    schedulePaymentStatusChecks
};----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/paystatus/paymentStatusService.js
/**
 * Payment Status Service
 * ---------------------
 * Purpose: Core business logic for payment status checking
 * 
 * Functions:
 * - Handle API requests for checking payment status
 * - Fetch pending payments that need status checks
 * - Route status checks to appropriate payment providers
 */

const pool = require('../../../config/database');
const poliPaymentStatus = require('./providers/poliPaymentStatus');
const stripePaymentStatus = require('./providers/stripePaymentStatus');
const alipayPaymentStatus = require('./providers/alipayPaymentStatus');
const btcpayPaymentStatus = require('./providers/btcpayPaymentStatus');
const blinkPaymentStatus = require('./providers/blinkPaymentStatus');

class PaymentStatusService {
    constructor() {
        // Map of payment providers to their status checking implementations
        this.providers = {
            'POLi': poliPaymentStatus,
            'STRIPE': stripePaymentStatus,
            'ALIPAY': alipayPaymentStatus,
            'BTCPAY': btcpayPaymentStatus,
            'BLINK': blinkPaymentStatus
        };
    }
    
    /**
     * Check status for a specific payment
     * Used by the API endpoint
     * @param {number} paymentId - Payment record ID
     * @returns {Object} Status check result
     */
    async checkPaymentStatus(paymentId) {
        try {
            // Get payment details
            const query = `
                SELECT record_id, payid, provider, status_pay
                FROM payments
                WHERE record_id = $1
            `;
            
            const result = await pool.query(query, [paymentId]);
            if (result.rows.length === 0) {
                throw new Error(`Payment not found: ${paymentId}`);
            }
            
            const payment = result.rows[0];
            if (!payment.payid) {
                throw new Error(`No payid for payment: ${paymentId}`);
            }
            
            // Get the appropriate provider implementation
            const providerImplementation = this.providers[payment.provider];
            if (!providerImplementation) {
                throw new Error(`No implementation for provider: ${payment.provider}`);
            }
            
            // Check the payment status
            const statusResult = await providerImplementation.checkStatus(payment.payid);
            
            // Log the status check result
            await this.logStatusCheck(payment.record_id, statusResult, statusResult.message);
            
            return {
                paymentId: payment.record_id,
                payid: payment.payid,
                provider: payment.provider,
                status: statusResult.status,
                payment_status: statusResult.payment_status || statusResult.status,
                message: statusResult.message
            };
        } catch (error) {
            console.error(`Error checking payment status for ID ${paymentId}:`, error);
            throw error;
        }
    }
    
    /**
     * Log a payment status check attempt to the pay_status table
     * @param {number} paymentId - Payment record ID
     * @param {Object} statusResult - Status result from provider
     * @param {string} message - Status message or error
     */
    async logStatusCheck(paymentId, statusResult, message) {
        try {
            // For providers that return both status types (dual-status):
            // - payment_status goes to pay_status.status
            // - status goes to payments.status_url
            // For single-status providers, use the same value for both
            
            const paymentStatus = statusResult.payment_status || statusResult.status;
            
            // Insert into pay_status table
            const query = `
                INSERT INTO pay_status (payments_record_id, date_time, status, message)
                VALUES ($1, NOW(), $2, $3)
            `;
            
            await pool.query(query, [paymentId, paymentStatus, message]);
            console.log(`Logged status check for payment ${paymentId}: ${paymentStatus}`);
            
            // Update the main payment record status
            if (statusResult.status) {
                await pool.query(
                    `UPDATE payments SET status_url = $1 WHERE record_id = $2`,
                    [statusResult.status, paymentId]
                );
                console.log(`Updated payment record ${paymentId} with status: ${statusResult.status}`);
            }
        } catch (error) {
            console.error(`Error logging status check for payment ${paymentId}:`, error);
            throw error;
        }
    }
}

module.exports = new PaymentStatusService();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/blinkService.js
/**
 * Blink Payment Service Integration
 * 
 * This service handles the integration with Blink Debit payment gateway.
 * Uses OAuth2 client credentials flow for authentication.
 * 
 * Required Environment Variables:
 * - BLINK_CLIENT_ID: OAuth2 client ID
 * - BLINK_CLIENT_SECRET: OAuth2 client secret
 * - BLINK_API_BASE_URL: Base URL for Blink API (e.g., https://sandbox.debit.blinkpay.co.nz/payments/v1)
 * - BLINK_AUTH_URL: Authentication endpoint (e.g., https://sandbox.debit.blinkpay.co.nz/oauth2/token)
 * - BLINK_REDIRECT_URL: Redirect URL after payment (e.g., https://your-domain.com)
 * - BLINK_PAYMENT_EXPIRY_MINUTES: Minutes until payment link expires (default: 30)
 */

const axios = require('axios');
const pool = require('../../config/database');
const crypto = require('crypto');
const expiryService = require('./expiry/expiryService');
const { schedulePaymentStatusChecks } = require('./paystatus/paymentStatusQueue');

class BlinkService {
    constructor() {
        // Initialize configuration from environment variables
        this.CLIENT_ID = process.env.BLINK_CLIENT_ID;
        this.CLIENT_SECRET = process.env.BLINK_CLIENT_SECRET;
        this.BASE_URL = process.env.BLINK_API_BASE_URL;
        this.AUTH_URL = process.env.BLINK_AUTH_URL;
        this.REDIRECT_URL = process.env.BLINK_REDIRECT_URL;
        
        // Token management
        this.accessToken = null;
        this.tokenExpiry = null;

        // Initialize expiry service
        this.expiryService = expiryService;

        // Configuration validation
        const requiredEnvVars = [
            'BLINK_CLIENT_ID',
            'BLINK_CLIENT_SECRET',
            'BLINK_API_BASE_URL',
            'BLINK_AUTH_URL',
            'BLINK_REDIRECT_URL',
            'BLINK_PAYMENT_EXPIRY_MINUTES'
        ];

        const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);
        if (missingVars.length > 0) {
            console.error('Missing required environment variables:', missingVars.join(', '));
            throw new Error('Missing required environment variables for Blink integration');
        }
    }

    async getAccessToken() {
        try {
            console.log('\n=== Blink Authentication ===');
            console.log('Requesting Blink access token...');
            
            const payload = {
                client_id: this.CLIENT_ID,
                client_secret: this.CLIENT_SECRET,
                grant_type: 'client_credentials',
                audience: 'https://api.blinkdebit.co.nz'
            };

            const response = await axios.post(
                this.AUTH_URL,
                payload,
                {
                    headers: {
                        'Content-Type': 'application/json'
                    }
                }
            );

            this.accessToken = response.data.access_token;
            this.tokenExpiry = Date.now() + (response.data.expires_in * 1000);
            
            console.log('Successfully obtained Blink access token');
            return this.accessToken;
        } catch (error) {
            console.error('Failed to get Blink access token:', error.response?.data || error.message);
            throw error;
        }
    }

    async ensureValidToken() {
        if (!this.accessToken || !this.tokenExpiry || Date.now() >= this.tokenExpiry - 60000) {
            await this.getAccessToken();
        }
        return this.accessToken;
    }

    async generatePaymentLink(orderData) {
        try {
            console.log('\n=== Blink Payment Processing ===');
            console.log('Generating Blink payment link for order:', orderData.trade_order);

            const token = await this.ensureValidToken();

            const formattedAmount = typeof orderData.total_price === 'string' 
                ? parseFloat(orderData.total_price).toFixed(2)
                : orderData.total_price.toFixed(2);

            const payload = {
                flow: {
                    detail: {
                        type: "gateway",
                        redirect_uri: this.REDIRECT_URL,
                        flow_hint: {
                            type: "redirect",
                            bank: "PNZ"
                        }
                    }
                },
                pcr: {
                    particulars: orderData.trade_order.substring(0, 12).replace(/[^a-zA-Z0-9- &#?:_\/,.']/g, ''),
                    code: orderData.trade_order.substring(0, 12).replace(/[^a-zA-Z0-9- &#?:_\/,.']/g, ''),
                    reference: orderData.record_id.toString().substring(0, 12)
                },
                amount: {
                    total: formattedAmount,
                    currency: "NZD"
                }
            };

            console.log('Blink API Payload:', JSON.stringify(payload));

            const headers = {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                'request-id': crypto.randomUUID(),
                'x-correlation-id': crypto.randomUUID(),
                'idempotency-key': crypto.randomUUID()
            };

            const response = await axios.post(
                `${this.BASE_URL}/quick-payments`,
                payload,
                {
                    headers: headers,
                    timeout: 10000
                }
            );

            console.log('Blink API Response:', response.data);

            if (response.data && response.data.redirect_uri) {
                const insertResult = await pool.query(
                    `INSERT INTO payments (
                        order_record_id, provider, status_url, amount, 
                        payment_url, payid, expires_at
                    ) VALUES ($1, $2, $3, $4, $5, $6, NOW() + interval '${process.env.BLINK_PAYMENT_EXPIRY_MINUTES} minutes')
                    RETURNING record_id`,
                    [
                        orderData.record_id, 
                        'BLINK', 
                        'success', 
                        formattedAmount, 
                        response.data.redirect_uri,
                        response.data.quick_payment_id
                    ]
                );

                // Schedule payment expiry
                await this.expiryService.scheduleExpiry(
                    response.data.quick_payment_id,
                    'BLINK'
                );

                // Schedule payment status checks
                schedulePaymentStatusChecks({
                    record_id: insertResult.rows[0].record_id,
                    provider: 'BLINK',
                    payid: response.data.quick_payment_id
                });

                return response.data.redirect_uri;
            } else {
                throw new Error('No redirect_uri in response');
            }

        } catch (error) {
            console.error('\n=== Blink API Error ===');
            console.error('Error details:', {
                message: error.message,
                response: error.response?.data,
                status: error.response?.status,
                headers: error.response?.headers,
                order: orderData.trade_order
            });
            
            await pool.query(
                `INSERT INTO payments (order_record_id, provider, status_url, amount, message_url) 
                 VALUES ($1, $2, $3, $4, $5)`,
                [orderData.record_id, 'BLINK', 'failed', orderData.total_price, 
                 error.response?.data?.detail || error.message]
            );
            
            console.error('Blink payment link generation failed for order:', orderData.trade_order);
            throw error;
        }
    }
}

module.exports = new BlinkService();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/alipayService.js
/**
 * Alipay Service Integration (via Stripe)
 * -------------------------------------
 * Purpose: Handles Alipay-specific payment processing through Stripe Checkout
 * 
 * Features:
 * - Creates Alipay-only payment links using Stripe Checkout
 * - Implements 3% processing fee for Alipay transactions
 * - Restricts payment method to Alipay only
 * - Supports CNY currency for Alipay transactions
 * 
 * Environment Variables:
 * - STRIPE_SECRET_KEY: Stripe API secret key
 * - STRIPE_BASE_URL: Base URL for Stripe API
 * - STRIPE_ALIPAY_FEE: Alipay processing fee (e.g., 0.03 for 3%)
 * - STRIPE_SUCCESS_URL: Success redirect URL
 * - STRIPE_CANCEL_URL: Cancel redirect URL
 */

const axios = require('axios');
const pool = require('../../config/database');
const { schedulePaymentStatusChecks } = require('./paystatus/paymentStatusQueue');

class AlipayService {
    constructor() {
        this.secretKey = process.env.STRIPE_SECRET_KEY;
        this.baseUrl = process.env.STRIPE_BASE_URL;
        this.feePercentage = parseFloat(process.env.STRIPE_ALIPAY_FEE) || 0.03;
        this.successUrl = process.env.STRIPE_SUCCESS_URL;
        this.cancelUrl = process.env.STRIPE_CANCEL_URL;

        // Validate configuration
        const requiredEnvVars = [
            'STRIPE_SECRET_KEY',
            'STRIPE_BASE_URL',
            'STRIPE_SUCCESS_URL',
            'STRIPE_CANCEL_URL',
            'STRIPE_ALIPAY_FEE'
        ];

        const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);
        if (missingVars.length > 0) {
            console.warn('Missing Alipay configuration:', missingVars.join(', '));
        }
    }

    /**
     * Calculates total amount including Alipay processing fee
     * @param {number} baseAmount - Original amount before fees
     * @returns {number} Total amount including fees
     */
    calculateTotalWithFees(baseAmount) {
        const amount = parseFloat(baseAmount);
        return amount * (1 + this.feePercentage);
    }

    /**
     * Generates an Alipay-only payment link via Stripe
     * @param {Object} orderData - Order information including amount and reference
     * @returns {String} Checkout session URL
     */
    async generatePaymentLink(orderData) {
        try {
            console.log('\n=== Alipay Payment Processing ===');
            console.log('Generating Alipay payment link for order:', orderData.trade_order);

            // Calculate total amount including Alipay fee
            const baseAmount = parseFloat(orderData.total_price);
            const totalWithFees = this.calculateTotalWithFees(baseAmount);
            const amountInCents = Math.round(totalWithFees * 100);

            console.log('Alipay payment calculation:', {
                baseAmount,
                feePercentage: this.feePercentage,
                totalWithFees,
                amountInCents
            });

            const payload = {
                mode: 'payment',
                success_url: this.successUrl,
                cancel_url: this.cancelUrl,
                payment_method_types: ['alipay'],
                currency: 'nzd',

                line_items: [{
                    price_data: {
                        currency: 'nzd',
                        product_data: {
                            name: orderData.product_name_full || 'Gold Purchase',
                            description: `Order: ${orderData.trade_order} (Includes Alipay fee)`
                        },
                        unit_amount: amountInCents
                    },
                    quantity: 1
                }],

                customer_email: orderData.email_order || undefined,
                client_reference_id: orderData.trade_order,
                expires_at: Math.floor(Date.now() / 1000) + (30 * 60)
            };

            const response = await axios.post(
                `${this.baseUrl}/v1/checkout/sessions`,
                payload,
                {
                    headers: {
                        'Authorization': `Bearer ${this.secretKey}`,
                        'Content-Type': 'application/x-www-form-urlencoded'
                    }
                }
            );

            console.log('Alipay Checkout Session created:', response.data.id);

            if (response.data && response.data.url) {
                // Store payment record
                const insertResult = await pool.query(
                    `INSERT INTO payments (
                        order_record_id, provider, status_url, amount, 
                        payment_url, payid, expires_at
                    ) VALUES ($1, $2, $3, $4, $5, $6, NOW() + interval '30 minutes')
                    RETURNING record_id`,
                    [
                        orderData.record_id,
                        'ALIPAY',
                        'success',
                        orderData.total_price,
                        response.data.url,
                        response.data.id
                    ]
                );

                // Schedule status checks at 1min and 3min after creation (for testing)
                schedulePaymentStatusChecks({
                    record_id: insertResult.rows[0].record_id,
                    provider: 'ALIPAY',
                    payid: response.data.id
                });

                return response.data.url;
            } else {
                throw new Error('Invalid response from Stripe for Alipay');
            }

        } catch (error) {
            console.error('\n=== Alipay API Error ===');
            console.error('Error details:', {
                message: error.message,
                response: error.response?.data,
                order: orderData.trade_order
            });

            // Store failed payment record
            await pool.query(
                `INSERT INTO payments (
                    order_record_id, provider, status_url, amount, message_url
                ) VALUES ($1, $2, $3, $4, $5)`,
                [
                    orderData.record_id,
                    'ALIPAY',
                    'failed',
                    orderData.total_price,
                    error.response?.data?.error?.message || error.message
                ]
            );

            throw error;
        }
    }
}

module.exports = new AlipayService();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/expiry/providers/blinkExpiry.js
const axios = require('axios');

class BlinkExpiryProvider {
    constructor() {
        this.baseUrl = process.env.BLINK_API_BASE_URL;
    }

    async revokePayment(payid, token) {
        try {
            console.log(`Revoking Blink payment: ${payid}`);
            
            await axios.delete(
                `${this.baseUrl}/quick-payments/${payid}`,
                {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    }
                }
            );

            console.log(`Successfully revoked Blink payment: ${payid}`);
            return true;
        } catch (error) {
            console.error(`Failed to revoke Blink payment ${payid}:`, error.response?.data || error.message);
            throw error;
        }
    }
}

module.exports = new BlinkExpiryProvider();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/expiry/expiryQueue.js
const Queue = require('bull');

const expiryQueue = new Queue('payment-expiry', process.env.REDIS_URL, {
    defaultJobOptions: {
        attempts: 3,
        backoff: {
            type: 'exponential',
            delay: 1000 // 1 second initial delay
        }
    }
});

// Log events for monitoring
expiryQueue.on('completed', job => {
    console.log(`Payment expiry job completed: ${job.id} for ${job.data.provider} payment ${job.data.payid}`);
});

expiryQueue.on('failed', (job, error) => {
    console.error(`Payment expiry job failed: ${job.id} for ${job.data.provider} payment ${job.data.payid}`, error);
});

module.exports = expiryQueue;----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/expiry/expiryService.js
/*
----------------------------------------------
commented out service. empty service below to not start the expiry checker 
---------------------------------------------------

const pool = require('../../config/database');
const expiryQueue = require('./expiryQueue');
const blinkExpiry = require('./providers/blinkExpiry');
const blinkService = require('../payments/blinkService'); // Changed to use instance

class PaymentExpiryService {
    constructor() {
        this.setupQueueProcessor();
    }

    setupQueueProcessor() {
        expiryQueue.process(async (job) => {
            const { payid, provider } = job.data;
            console.log(`Processing expiry for ${provider} payment ${payid}`);
            
            try {
                await this.processExpiry(payid, provider);
                return { success: true, payid, provider };
            } catch (error) {
                // Check if error is due to payment already being expired or invalid
                if (error.response?.status === 404 || error.response?.status === 410) {
                    console.log(`Payment ${payid} already expired or invalid`);
                    await this.updatePaymentStatus(payid, 'expired', 'Payment already expired');
                    return { success: true, payid, provider, status: 'already_expired' };
                }

                console.error(`Expiry processing failed for ${payid}:`, error);
                throw error;
            }
        });
    }

    async updatePaymentStatus(payid, status, message) {
        const client = await pool.connect();
        try {
            await client.query(
                `UPDATE payments 
                 SET status = $1, 
                     error_message = $2
                 WHERE payid = $3`,
                [status, message, payid]
            );
        } finally {
            client.release();
        }
    }

    async processExpiry(payid, provider) {
        const client = await pool.connect();
        
        try {
            await client.query('BEGIN');

            // Get payment details
            const { rows } = await client.query(
                'SELECT * FROM payments WHERE payid = $1 AND provider = $2',
                [payid, provider]
            );

            if (!rows.length) {
                throw new Error(`Payment ${payid} not found`);
            }

            const payment = rows[0];

            // Only process if payment is still active
            if (payment.status === 'success') {
                // Handle provider-specific revocation
                switch (provider) {
                    case 'BLINK':
                        const token = await blinkService.ensureValidToken();
                        await blinkExpiry.revokePayment(payid, token);
                        break;
                    default:
                        throw new Error(`Unsupported payment provider: ${provider}`);
                }

                // Update payment status
                await client.query(
                    `UPDATE payments 
                     SET status = 'expired', 
                         error_message = 'Payment link expired'
                     WHERE payid = $1`,
                    [payid]
                );

                console.log(`Successfully expired ${provider} payment ${payid}`);
            } else {
                console.log(`Payment ${payid} already in ${payment.status} status, skipping expiry`);
            }

            await client.query('COMMIT');
        } catch (error) {
            await client.query('ROLLBACK');
            throw error;
        } finally {
            client.release();
        }
    }

    async scheduleExpiry(payid, provider) {
        // Set expiry slightly shorter than Blink's expiry to ensure we revoke first
        const expiryMinutes = (parseInt(process.env.BLINK_PAYMENT_EXPIRY_MINUTES) || 30) - 2;
        
        console.log(`Scheduling expiry for ${provider} payment ${payid} in ${expiryMinutes} minutes`);
        
        // Schedule job
        await expiryQueue.add(
            { payid, provider },
            { 
                delay: expiryMinutes * 60 * 1000,
                jobId: `${provider}-${payid}`,
                attempts: 3,
                backoff: {
                    type: 'exponential',
                    delay: 1000
                }
            }
        );

        console.log(`Expiry scheduled for ${provider} payment ${payid}`);
    }
}

module.exports = new PaymentExpiryService();


*/


const pool = require('../../../config/database');
const blinkExpiry = require('./providers/blinkExpiry');
const blinkService = require('../blinkService'); // Changed to use instance

class PaymentExpiryService {
    constructor() {
        this.setupQueueProcessor();
    }

    setupQueueProcessor() {
        // No processing setup required as we are disabling the expiry queue
    }

    async updatePaymentStatus(payid, status, message) {
        const client = await pool.connect();
        try {
            await client.query(
                `UPDATE payments 
                 SET status = $1, 
                     error_message = $2
                 WHERE payid = $3`,
                [status, message, payid]
            );
        } finally {
            client.release();
        }
    }

    async processExpiry(payid, provider) {
        const client = await pool.connect();
        
        try {
            await client.query('BEGIN');

            // Get payment details
            const { rows } = await client.query(
                'SELECT * FROM payments WHERE payid = $1 AND provider = $2',
                [payid, provider]
            );

            if (!rows.length) {
                throw new Error(`Payment ${payid} not found`);
            }

            const payment = rows[0];

            // Only process if payment is still active
            if (payment.status === 'success') {
                // Handle provider-specific revocation
                switch (provider) {
                    case 'BLINK':
                        const token = await blinkService.ensureValidToken();
                        await blinkExpiry.revokePayment(payid, token);
                        break;
                    default:
                        throw new Error(`Unsupported payment provider: ${provider}`);
                }

                // Update payment status
                await client.query(
                    `UPDATE payments 
                     SET status = 'expired', 
                         error_message = 'Payment link expired'
                     WHERE payid = $1`,
                    [payid]
                );

                console.log(`Successfully expired ${provider} payment ${payid}`);
            } else {
                console.log(`Payment ${payid} already in ${payment.status} status, skipping expiry`);
            }

            await client.query('COMMIT');
        } catch (error) {
            await client.query('ROLLBACK');
            throw error;
        } finally {
            client.release();
        }
    }

    async scheduleExpiry(payid, provider) {
        // This method is intentionally left blank to disable expiry scheduling
    }
}

module.exports = new PaymentExpiryService();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/btcpayService.js
/**
 * BTCPay Server Payment Integration
 */

const axios = require('axios');
const pool = require('../../config/database');
const { schedulePaymentStatusChecks } = require('./paystatus/paymentStatusQueue');

class BTCPayService {
    constructor() {
        // Remove trailing slash if present in API URL
        this.API_URL = process.env.BTCPAY_API_URL?.replace(/\/$/, '');
        this.API_KEY = process.env.BTCPAY_API_KEY;
        this.STORE_ID = process.env.BTCPAY_STORE_ID;

        // Validate configuration
        if (!this.API_URL || !this.API_KEY || !this.STORE_ID) {
            console.warn('BTCPay Server configuration incomplete');
        }
    }

    async generatePaymentLink(orderData) {
        try {
            console.log('\n=== BTCPay Payment Processing ===');
            console.log('Generating BTCPay invoice for order:', orderData.trade_order);

            // Format amount properly
            const formattedAmount = typeof orderData.total_price === 'string' 
                ? parseFloat(orderData.total_price).toFixed(2)
                : orderData.total_price.toFixed(2);

            const payload = {
                metadata: {
                    orderId: orderData.trade_order,
                    buyerName: orderData.first_name_order,
                    buyerEmail: orderData.email_order,
                    itemDesc: orderData.product_name_full || 'Gold Purchase'
                },
                amount: formattedAmount,
                currency: "NZD",
                checkout: {
                    speedPolicy: "MediumSpeed",
                    paymentMethods: ["BTC"],
                    redirectURL: process.env.BTCPAY_REDIRECT_URL,
                    defaultLanguage: "en"
                }
            };

            console.log('BTCPay request configuration:', {
                url: `${this.API_URL}/api/v1/stores/${this.STORE_ID}/invoices`,
                storeId: this.STORE_ID,
                authHeader: `token ${this.API_KEY}`
            });

            const response = await axios.post(
                `${this.API_URL}/api/v1/stores/${this.STORE_ID}/invoices`,
                payload,
                {
                    headers: {
                        'Authorization': `token ${this.API_KEY}`,
                        'Content-Type': 'application/json'
                    }
                }
            );

            console.log('BTCPay API Response:', response.data);

            if (response.data && response.data.checkoutLink) {
                // Store payment record
                const insertResult = await pool.query(
                    `INSERT INTO payments (
                        order_record_id, provider, status_url, amount, 
                        payment_url, payid
                    ) VALUES ($1, $2, $3, $4, $5, $6)
                    RETURNING record_id`,
                    [
                        orderData.record_id,
                        'BTCPAY',
                        'success',
                        formattedAmount,
                        response.data.checkoutLink,
                        response.data.id
                    ]
                );

                // Schedule status checks at 1min and 3min after creation (for testing)
                schedulePaymentStatusChecks({
                    record_id: insertResult.rows[0].record_id,
                    provider: 'BTCPAY',
                    payid: response.data.id
                });

                return response.data.checkoutLink;
            } else {
                throw new Error('Invalid response from BTCPay Server');
            }

        } catch (error) {
            console.error('\n=== BTCPay API Error ===');
            console.error('Error details:', {
                message: error.message,
                response: error.response?.data,
                order: orderData.trade_order,
                config: error.config
            });

            // Store failed payment record
            await pool.query(
                `INSERT INTO payments (
                    order_record_id, provider, status_url, amount, message_url
                ) VALUES ($1, $2, $3, $4, $5)`,
                [
                    orderData.record_id,
                    'BTCPAY',
                    'failed',
                    orderData.total_price,
                    error.response?.data?.message || error.message
                ]
            );

            throw error;
        }
    }
}

module.exports = new BTCPayService();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/paymentService.js
/**
 * Payment Service
 * --------------
 * Purpose: Handles payment status checking
 * Role: Provides business logic for payment status
 * 
 * Key Functions:
 * - Check payment status by token
 * 
 * Dependencies:
 * - Database pool for queries
 * 
 * Supported Payment Methods:
 * - POLi Payments
 * - Blink Payments
 * - BTCPay (Bitcoin)
 * - Stripe (Credit Card)
 * - Alipay (via Stripe)
 */

const pool = require('../../config/database');

class PaymentService {
    /**
     * Gets payment status and available payment URLs by token
     * Includes all available payment methods for the order
     * @param {string} token - Order token
     * @returns {Object} Payment status and available payment URLs
     */
    async getStatusByToken(token) {
        console.log('Checking payment status for token:', token);

        const query = `
            SELECT 
                p.payment_url,
                p.status_url,
                p.created_at,
                p.message_url,
                p.provider,
                p.expires_at
            FROM payments p
            JOIN orders o ON o.record_id = p.order_record_id
            WHERE o.token = $1
            AND p.status_url = 'success'
            AND (p.expires_at IS NULL OR p.expires_at > NOW())
            ORDER BY p.created_at DESC
        `;

        try {
            const result = await pool.query(query, [token]);
            console.log('Payment status results:', result.rows);

            // If no payment records found
            if (!result.rows.length) {
                return { 
                    status: 'pending',
                    message: 'Payment processing' 
                };
            }

            // Create an object to hold payment URLs for all providers
            const paymentUrls = {};
            
            // Process all successful payment records
            result.rows.forEach(row => {
                if (row.status_url === 'success' && row.payment_url) {
                    paymentUrls[row.provider] = {
                        payment_url: row.payment_url,
                        provider: row.provider,
                        expires_at: row.expires_at
                    };
                }
            });

            return {
                status: 'success',
                payments: paymentUrls,
                checked_at: new Date().toISOString()
            };

        } catch (error) {
            console.error('Database error in getStatusByToken:', error);
            throw new Error('Failed to check payment status');
        }
    }

    /**
     * Utility method to format expiry timestamp
     * @private
     * @param {Date} date - Expiry date
     * @returns {string} Formatted timestamp
     */
    _formatExpiryTime(date) {
        return date.toISOString();
    }

    /**
     * Checks if a payment URL has expired
     * @private
     * @param {Date} expiryDate - Payment URL expiry date
     * @returns {boolean} True if expired
     */
    _isExpired(expiryDate) {
        return new Date() > new Date(expiryDate);
    }
}

module.exports = new PaymentService();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/orders/orderService.js
/**
 * Order Service Module
 * ===================
 * This service handles the creation and management of orders in the system.
 * It provides functionality for:
 * - Generating unique trade order numbers
 * - Creating new orders with customer and product details
 * - Managing order transactions with database integration
 * - Generating payment links through multiple payment providers
 * 
 * Key Requirements:
 * - PostgreSQL database connection
 * - JWT for token generation
 * - POLi payment service integration
 * - Blink payment service integration
 * - BTCPay Server integration for Bitcoin payments
 * - Stripe payment service integration
 * - Alipay payment service integration
 * - Environment variables for JWT secret
 */

const pool = require('../../config/database');
const jwt = require('jsonwebtoken');
const PoliService = require('../payments/poliService');
const BlinkService = require('../payments/blinkService');
const BTCPayService = require('../payments/btcpayService');
const StripeService = require('../payments/stripeService');
const AlipayService = require('../payments/alipayService');

class OrderService {
    /**
     * Generates the next sequential trade order number
     * Formats: "TO-XXXX" where XXXX is an incrementing number
     * Default starts at TO-2317 if no previous orders exist
     */
    async getNextTradeOrder() {
        const result = await pool.query("SELECT trade_order FROM orders ORDER BY record_id DESC LIMIT 1");

        // ⚠️ CONFIGURE: Change starting number if needed
        const DEFAULT_START = "TO-2317";

        if (result.rows.length === 0 || !result.rows[0].trade_order || result.rows[0].trade_order.trim() === "") {
            return DEFAULT_START;
        }

        const lastTradeOrder = result.rows[0].trade_order.trim();

        if (typeof lastTradeOrder === "string" && lastTradeOrder.startsWith("TO-")) {
            const lastNumber = parseInt(lastTradeOrder.replace("TO-", ""), 10);
            return `TO-${lastNumber + 1}`;
        }

        return DEFAULT_START;
    }

    /**
     * Creates a new order in the system
     * @param {Object} orderData - Contains all order details including customer info and product details
     * @returns {Object} Contains generated token and trade order number
     */
    async createOrder(orderData) {
        const {
            first_name_order, email_order, total_price, // Required fields
            last_name_order, phone_order, product_name_full, quantity, price_nzd,
            zoho_id, delivery, pay_in_person, checkbox_order, address, message,
            date_picker_order, time_picker_order
        } = orderData;

        // Input validation for required fields
        if (!first_name_order || !email_order || !total_price) {
            throw new Error("First name, email, and total price are required.");
        }

        const trade_order = await this.getNextTradeOrder();

        // Database transaction handling
        const client = await pool.connect();
        try {
            await client.query('BEGIN');

            // Generate JWT token for order tracking
            const token = jwt.sign(
                { trade_order, email_order, timestamp: Date.now() },
                process.env.JWT_SECRET || "default_secret",
                { expiresIn: "1h" }
            );

            // Insert order into database
            const orderResult = await client.query(
                `INSERT INTO orders (
                    trade_order, first_name_order, last_name_order, email_order, phone_order,
                    product_name_full, total_price, quantity, price_nzd, zoho_id, delivery,
                    pay_in_person, checkbox_order, address, message, token,
                    date_picker_order, time_picker_order
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
                RETURNING record_id, order_creation_time`,
                [
                    trade_order, first_name_order, last_name_order || null, email_order, phone_order || null,
                    product_name_full || null, total_price, quantity || null, price_nzd || null, zoho_id || null,
                    delivery || null, pay_in_person || null, checkbox_order || null, address || null,
                    message || null, token, date_picker_order || null, time_picker_order || null
                ]
            );

            await client.query('COMMIT');

            // Prepare order data for payment processing
            const orderWithId = {
                ...orderData,
                record_id: orderResult.rows[0].record_id,
                trade_order
            };

            // Format timestamp for New Zealand timezone
            const timestamp = orderResult.rows[0].order_creation_time;
            const formattedDate = new Date(timestamp).toLocaleString('en-NZ', {
                timeZone: 'Pacific/Auckland',
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            }).replace(/\//g, '-');

            // Asynchronously generate payment links
            this.generatePaymentLinks(orderWithId);

            return { token, trade_order, order_creation_time: formattedDate };

        } catch (error) {
            await client.query('ROLLBACK');
            throw error;
        } finally {
            client.release();
        }
    }

    /**
     * Generates payment links through multiple payment providers
     * Runs asynchronously to not block the order creation process
     * Handles all payment processing in parallel
     * @param {Object} orderData - Complete order information including record_id
     */
    async generatePaymentLinks(orderData) {
        try {
            console.log('\n=== Starting Payment Processing ===');
            console.log('Processing order:', orderData.trade_order);
            
            await Promise.all([
                // POLi payment processing
                (async () => {
                    try {
                        await PoliService.generatePaymentLink(orderData);
                    } catch (error) {
                        console.error('POLi processing failed:', error.message);
                    }
                })(),
                // Blink payment processing
                (async () => {
                    try {
                        await BlinkService.generatePaymentLink(orderData);
                    } catch (error) {
                        console.error('Blink processing failed:', error.message);
                    }
                })(),
                // BTCPay processing
                (async () => {
                    try {
                        if (process.env.BTCPAY_API_KEY && process.env.BTCPAY_STORE_ID) {
                            await BTCPayService.generatePaymentLink(orderData);
                        } else {
                            console.log('BTCPay configuration not found, skipping Bitcoin payment processing');
                        }
                    } catch (error) {
                        console.error('BTCPay processing failed:', error.message);
                    }
                })(),
                // Stripe payment processing
                (async () => {
                    try {
                        if (process.env.STRIPE_SECRET_KEY) {
                            await StripeService.generatePaymentLink(orderData);
                        } else {
                            console.log('Stripe configuration not found, skipping Stripe payment processing');
                        }
                    } catch (error) {
                        console.error('Stripe processing failed:', error.message);
                    }
                })(),
                // Alipay processing
                (async () => {
                    try {
                        if (process.env.STRIPE_ALIPAY_FEE) {
                            await AlipayService.generatePaymentLink(orderData);
                        } else {
                            console.log('Alipay configuration not found, skipping Alipay payment processing');
                        }
                    } catch (error) {
                        console.error('Alipay processing failed:', error.message);
                    }
                })()
            ]);

            console.log('=== Payment Processing Complete ===\n');
        } catch (error) {
            console.error('Payment link generation failed:', error);
            // Don't throw - this is background processing
        }
    }
}

module.exports = new OrderService();----------------------------------------

=== Adding files from /views directory ===
-e 
=== File: /workspaces/mware3/views/admin/payments.ejs
<!DOCTYPE html>
<html>
<head>
  <title>Payments Admin Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
    }
    
    .container-fluid {
      padding-left: 5%;
      padding-right: 5%;
      width: 100%;
      max-width: 100%;
    }
    
    .table-responsive { overflow-x: auto; }
    
    /* Status colors */
    .status-completed { color: green; font-weight: bold; }
    .status-pending { color: orange; }
    .status-failed, .status-error { color: red; }
    .status-success { color: green; font-weight: bold; }
    .status-expired { color: #dc3545; }
    
    .filter-form { margin-bottom: 20px; }
    .filter-section { 
      margin-bottom: 15px; 
      padding: 10px 15px;
      background-color: #f8f9fa;
      border-radius: 6px;
    }
    
    .checkbox-group { 
      display: flex; 
      gap: 15px; 
      flex-wrap: wrap; 
      margin-top: 5px;
    }
    
    /* Customer info formatting */
    .customer-info { display: flex; flex-direction: column; }
    .customer-detail { margin-bottom: 2px; }
    .customer-email { font-weight: bold; }
    .customer-phone { color: #6c757d; }
    
    /* Order number styling */
    .order-number { font-weight: bold; color: #0d6efd; }
    
    /* Status badges */
    .status-badge {
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 0.8rem;
      font-weight: 500;
      display: inline-block;
      margin-bottom: 3px;
    }
    .badge-completed { background-color: #d1e7dd; color: #0f5132; }
    .badge-pending { background-color: #fff3cd; color: #664d03; }
    .badge-failed, .badge-error { background-color: #f8d7da; color: #842029; }
    .badge-expired { background-color: #f8d7da; color: #842029; }
    .badge-success { background-color: #d1e7dd; color: #0f5132; }
    
    /* Reviewed status styles */
    .reviewed-yes { 
      background-color: #d1e7dd; 
      color: #0f5132;
      border-radius: 12px;
      padding: 3px 8px;
      font-size: 0.8rem;
    }
    .reviewed-no { 
      background-color: #e2e3e5; 
      color: #41464b;
      border-radius: 12px;
      padding: 3px 8px;
      font-size: 0.8rem;
    }
    
    /* Button styling */
    .action-btn {
      white-space: nowrap;
      width: auto;
      min-width: 90px;
    }
    
    /* Export CSV section */
    .export-section {
      background-color: #f8f9fa;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
    }
    
    .date-range-picker {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }
    
    .export-btn {
      margin-top: 10px;
    }
    
    /* Section styling */
    .filter-section-header {
      font-weight: bold;
      margin-bottom: 8px;
      color: #495057;
    }
    
    /* Status filter sections */
    .status-filter-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
    }
    
    .status-filter-section {
      flex: 1;
      min-width: 280px;
    }
    
    /* Responsive design */
    @media (max-width: 768px) {
      .checkbox-group { flex-wrap: wrap; }
      th, td { font-size: 0.85rem; }
      .container-fluid {
        padding-left: 15px;
        padding-right: 15px;
      }
      .date-range-picker {
        flex-direction: column;
        align-items: stretch;
      }
      .status-filter-container {
        flex-direction: column;
        gap: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="container-fluid mt-4">
    <div class="d-flex justify-content-between align-items-center mb-3">
      <h1>Payments Dashboard</h1>
      <button class="btn btn-outline-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#exportSection">
        Export CSV
      </button>
    </div>
    
    <!-- CSV Export Section (Collapsible) -->
    <div class="collapse mb-4" id="exportSection">
      <div class="export-section">
        <h5>Export Payment Data as CSV</h5>
        <form id="exportForm" action="/admin/export-csv" method="GET">
          <div class="row">
            <div class="col-md-5">
              <label class="form-label">Start Date</label>
              <input type="date" class="form-control" id="startDate" name="startDate" required>
            </div>
            <div class="col-md-5">
              <label class="form-label">End Date</label>
              <input type="date" class="form-control" id="endDate" name="endDate" required>
            </div>
            <div class="col-md-2 d-flex align-items-end">
              <button type="submit" class="btn btn-primary w-100">Export</button>
            </div>
          </div>
        </form>
      </div>
    </div>
    
    <!-- Filter Form -->
    <div class="card mb-4">
      <div class="card-body">
        <form class="filter-form" method="GET" id="filterForm">
          <div class="row g-3">
            <div class="col-md-3">
              <label class="form-label">Search (Email/Phone)</label>
              <input type="text" class="form-control" name="search" value="<%= search %>" placeholder="Search by email or phone">
            </div>
            <div class="col-md-3">
              <label class="form-label">Search Order Number</label>
              <input type="text" class="form-control" name="searchTO" value="<%= searchTO %>" placeholder="Search TO-xxxx">
            </div>
            <div class="col-md-3">
              <label class="form-label">Provider</label>
              <select class="form-select" name="provider">
                <option value="">All Providers</option>
                <option value="POLi" <% if (provider === 'POLi') { %>selected<% } %>>POLi</option>
                <option value="STRIPE" <% if (provider === 'STRIPE') { %>selected<% } %>>Stripe</option>
                <option value="BLINK" <% if (provider === 'BLINK') { %>selected<% } %>>Blink</option>
                <option value="BTCPAY" <% if (provider === 'BTCPAY') { %>selected<% } %>>BTCPay</option>
                <option value="ALIPAY" <% if (provider === 'ALIPAY') { %>selected<% } %>>Alipay</option>
              </select>
            </div>
            <div class="col-md-3">
              <label class="form-label">Reviewed Status</label>
              <select class="form-select" name="reviewedFilter">
                <option value="all" <% if (reviewedFilter === 'all') { %>selected<% } %>>All</option>
                <option value="yes" <% if (reviewedFilter === 'yes') { %>selected<% } %>>Reviewed</option>
                <option value="no" <% if (reviewedFilter === 'no') { %>selected<% } %>>Not Reviewed</option>
              </select>
            </div>
          </div>
          
          <!-- Status Filters -->
          <div class="filter-section mt-4">
            <div class="status-filter-container">
              <!-- Payment Status (status_pay) Section -->
              <div class="status-filter-section">
                <div class="filter-section-header">Status Pay:</div>
                <div class="checkbox-group">
                  <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="statusPayFilter" value="completed" id="statusCompleted" 
                      <% if (statusPayFilter && statusPayFilter.includes('completed')) { %>checked<% } %>>
                    <label class="form-check-label status-completed" for="statusCompleted">Completed</label>
                  </div>
                  <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="statusPayFilter" value="pending" id="statusPending"
                      <% if (statusPayFilter && statusPayFilter.includes('pending')) { %>checked<% } %>>
                    <label class="form-check-label status-pending" for="statusPending">Pending</label>
                  </div>
                  <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="statusPayFilter" value="failed" id="statusFailed"
                      <% if (statusPayFilter && statusPayFilter.includes('failed')) { %>checked<% } %>>
                    <label class="form-check-label status-failed" for="statusFailed">Failed</label>
                  </div>
                  <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="statusPayFilter" value="error" id="statusError"
                      <% if (statusPayFilter && statusPayFilter.includes('error')) { %>checked<% } %>>
                    <label class="form-check-label status-error" for="statusError">Error</label>
                  </div>
                </div>
              </div>
              
              <!-- URL Status (status_url) Section -->
              <div class="status-filter-section">
                <div class="filter-section-header">Status URL:</div>
                <div class="checkbox-group">
                  <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="statusUrlFilter" value="success" id="statusUrlSuccess"
                      <% if (statusUrlFilter && statusUrlFilter.includes('success')) { %>checked<% } %>>
                    <label class="form-check-label status-success" for="statusUrlSuccess">Success</label>
                  </div>
                  <div class="form-check">
                    <input class="form-check-input" type="checkbox" name="statusUrlFilter" value="expired" id="statusUrlExpired"
                      <% if (statusUrlFilter && statusUrlFilter.includes('expired')) { %>checked<% } %>>
                    <label class="form-check-label status-expired" for="statusUrlExpired">Expired</label>
                  </div>
                </div>
              </div>
            </div>
          </div>
          
          <div class="d-flex justify-content-end mt-3">
            <button type="submit" class="btn btn-primary">Apply Filters</button>
          </div>
        </form>
      </div>
    </div>

    <!-- Results Table -->
    <div class="card">
      <div class="card-body">
        <div class="table-responsive">
          <table class="table table-striped table-hover">
            <thead>
              <tr>
                <th>ID</th>
                <th>Date</th>
                <th>Order</th>
                <th>Customer Name</th>
                <th>Customer Email</th>
                <th>Phone</th>
                <th>Provider</th>
                <th>Amount</th>
                <th>Status Pay</th>
                <th>Status URL</th>
                <th>Reviewed</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="paymentsTableBody">
              <% if (payments && payments.length > 0) { %>
                <% payments.forEach(payment => { %>
                  <tr data-payment-id="<%= payment.record_id %>">
                    <td><%= payment.record_id %></td>
                    <td><%= new Date(payment.created_at).toLocaleString() %></td>
                    <td>
                      <% if (payment.trade_order) { %>
                        <a href="/admin/order/<%= payment.trade_order %>" class="order-number" title="View Order Details"><%= payment.trade_order %></a>
                      <% } else { %>
                        <span class="text-muted">N/A</span>
                      <% } %>
                    </td>
                    <td>
                      <%= payment.first_name_order || '' %> <%= payment.last_name_order || '' %>
                    </td>
                    <td><%= payment.email_order || '' %></td>
                    <td><%= payment.phone_order || '' %></td>
                    <td><%= payment.provider %></td>
                    <td>$<%= parseFloat(payment.amount || 0).toFixed(2) %></td>
                    <td>
                      <span class="status-badge badge-<%= (payment.status_pay || 'pending').toLowerCase() %>">
                        <%= payment.status_pay || 'pending' %>
                      </span>
                    </td>
                    <td>
                      <% if (payment.status_url) { %>
                        <span class="status-badge badge-<%= (payment.status_url).toLowerCase() %>">
                          <%= payment.status_url %>
                        </span>
                      <% } else { %>
                        <span class="text-muted">N/A</span>
                      <% } %>
                    </td>
                    <td class="reviewed-status">
                      <% if (payment.reviewed === 'yes' || payment.reviewed === 'Yes') { %>
                        <span class="reviewed-yes">Yes</span>
                      <% } else { %>
                        <span class="reviewed-no">No</span>
                      <% } %>
                    </td>
                    <td>
                      <div class="btn-group" role="group">
                        <% if (payment.payment_url) { %>
                          <a href="<%= payment.payment_url %>" target="_blank" class="btn btn-sm btn-outline-primary action-btn">View</a>
                        <% } %>
                        <button class="btn btn-sm <%= (payment.reviewed === 'yes' || payment.reviewed === 'Yes') ? 'btn-success' : 'btn-outline-secondary' %> action-btn mark-reviewed-btn" 
                                onclick="markReviewed(<%= payment.record_id %>)"
                                <%= (payment.reviewed === 'yes' || payment.reviewed === 'Yes') ? 'disabled' : '' %>>
                          <%= (payment.reviewed === 'yes' || payment.reviewed === 'Yes') ? 'Reviewed' : 'Review' %>
                        </button>
                      </div>
                    </td>
                  </tr>
                <% }); %>
              <% } else { %>
                <tr>
                  <td colspan="12" class="text-center">No payments found</td>
                </tr>
              <% } %>
            </tbody>
          </table>
        </div>
        
        <!-- Pagination -->
        <div class="d-flex justify-content-between align-items-center mt-3">
          <div>
            Showing <%= payments.length %> of <%= totalPayments %> payments
          </div>
          <nav aria-label="Page navigation">
            <ul class="pagination">
              <% if (page > 1) { %>
                <li class="page-item">
                  <a class="page-link" href="?page=<%= page-1 %>&limit=<%= limit %>&search=<%= search %>&searchTO=<%= searchTO %>&provider=<%= provider %>&reviewedFilter=<%= reviewedFilter %><% if (statusPayFilter && statusPayFilter.length > 0) { statusPayFilter.forEach(status => { %>&statusPayFilter=<%= status %><% })} %><% if (statusUrlFilter && statusUrlFilter.length > 0) { statusUrlFilter.forEach(status => { %>&statusUrlFilter=<%= status %><% })} %>">Previous</a>
                </li>
              <% } %>
              
              <% for(let i = Math.max(1, page-2); i <= Math.min(totalPages, page+2); i++) { %>
                <li class="page-item <%= i === page ? 'active' : '' %>">
                  <a class="page-link" href="?page=<%= i %>&limit=<%= limit %>&search=<%= search %>&searchTO=<%= searchTO %>&provider=<%= provider %>&reviewedFilter=<%= reviewedFilter %><% if (statusPayFilter && statusPayFilter.length > 0) { statusPayFilter.forEach(status => { %>&statusPayFilter=<%= status %><% })} %><% if (statusUrlFilter && statusUrlFilter.length > 0) { statusUrlFilter.forEach(status => { %>&statusUrlFilter=<%= status %><% })} %>"><%= i %></a>
                </li>
              <% } %>
              
              <% if (page < totalPages) { %>
                <li class="page-item">
                  <a class="page-link" href="?page=<%= page+1 %>&limit=<%= limit %>&search=<%= search %>&searchTO=<%= searchTO %>&provider=<%= provider %>&reviewedFilter=<%= reviewedFilter %><% if (statusPayFilter && statusPayFilter.length > 0) { statusPayFilter.forEach(status => { %>&statusPayFilter=<%= status %><% })} %><% if (statusUrlFilter && statusUrlFilter.length > 0) { statusUrlFilter.forEach(status => { %>&statusUrlFilter=<%= status %><% })} %>">Next</a>
                </li>
              <% } %>
            </ul>
          </nav>
        </div>
      </div>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script>
    // Initialize date pickers
    document.addEventListener('DOMContentLoaded', function() {
      // Set default dates (current month)
      const today = new Date();
      const firstDay = new Date(today.getFullYear(), today.getMonth(), 1);
      
      document.getElementById('startDate').valueAsDate = firstDay;
      document.getElementById('endDate').valueAsDate = today;
      
      // Handle export form submission
      document.getElementById('exportForm').addEventListener('submit', function(e) {
        const startDate = document.getElementById('startDate').value;
        const endDate = document.getElementById('endDate').value;
        
        if (!startDate || !endDate) {
          e.preventDefault();
          alert('Please select both start and end dates');
          return false;
        }
        
        if (new Date(startDate) > new Date(endDate)) {
          e.preventDefault();
          alert('Start date must be before end date');
          return false;
        }
        
        // Form is valid, will submit normally
      });
    });
    
    // Function to mark payment as reviewed
    function markReviewed(paymentId) {
      const btn = event.target;
      btn.disabled = true;
      btn.textContent = 'Updating...';
      
      // Log debugging info
      console.log(`Marking payment ID ${paymentId} as reviewed`);
      
      fetch(`/admin/api/mark-reviewed/${paymentId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        }
      })
        .then(response => {
          console.log('Response status:', response.status);
          return response.json();
        })
        .then(data => {
          console.log('Response data:', data);
          
          if (data.success) {
            // Update the button and status cell
            btn.textContent = 'Reviewed';
            btn.classList.add('btn-success');
            btn.classList.remove('btn-outline-secondary');
            
            // Update the reviewed status cell
            const row = document.querySelector(`tr[data-payment-id="${paymentId}"]`);
            const reviewedCell = row.querySelector('.reviewed-status');
            reviewedCell.innerHTML = '<span class="reviewed-yes">Yes</span>';
          } else {
            alert('Error: ' + (data.error || 'Unknown error'));
            btn.disabled = false;
            btn.textContent = 'Review';
          }
        })
        .catch(error => {
          console.error('Fetch error:', error);
          alert('Error marking as reviewed: ' + error);
          btn.disabled = false;
          btn.textContent = 'Review';
        });
    }
    
    // Auto-refresh dashboard every 30 seconds
    function refreshDashboard() {
      console.log("Refreshing dashboard data...");
      
      // Get current filter parameters
      const formData = new FormData(document.getElementById('filterForm'));
      const params = new URLSearchParams(formData);
      
      fetch(`/admin/payments/data?${params.toString()}`)
        .then(response => response.json())
        .then(data => {
          if (data && data.success && data.payments && data.payments.length > 0) {
            updateTable(data.payments);
          }
        })
        .catch(error => console.error('Error refreshing dashboard:', error));
    }
    
    function updateTable(payments) {
      const tableBody = document.getElementById('paymentsTableBody');
      
      // Update existing rows and add new ones
      payments.forEach(payment => {
        const existingRow = document.querySelector(`tr[data-payment-id="${payment.record_id}"]`);
        
        if (existingRow) {
          // Update status cells
          updateRowData(existingRow, payment);
        } else {
          // Create new row for new payment
          const newRow = document.createElement('tr');
          newRow.setAttribute('data-payment-id', payment.record_id);
          
          // Determine status classes
          const statusPayClass = `badge-${(payment.status_pay || 'pending').toLowerCase()}`;
          const statusUrlClass = payment.status_url ? `badge-${payment.status_url.toLowerCase()}` : '';
          const reviewedStatus = payment.reviewed === 'yes' || payment.reviewed === 'Yes';
          
          newRow.innerHTML = `
            <td>${payment.record_id}</td>
            <td>${new Date(payment.created_at).toLocaleString()}</td>
            <td>
              ${payment.trade_order ? 
                `<a href="/admin/order/${payment.trade_order}" class="order-number" title="View Order Details">${payment.trade_order}</a>` : 
                `<span class="text-muted">N/A</span>`}
            </td>
            <td>${payment.first_name_order || ''} ${payment.last_name_order || ''}</td>
            <td>${payment.email_order || ''}</td>
            <td>${payment.phone_order || ''}</td>
            <td>${payment.provider}</td>
            <td>$${parseFloat(payment.amount || 0).toFixed(2)}</td>
            <td>
              <span class="status-badge ${statusPayClass}">
                ${payment.status_pay || 'pending'}
              </span>
            </td>
            <td>
              ${payment.status_url ? 
                `<span class="status-badge ${statusUrlClass}">${payment.status_url}</span>` : 
                `<span class="text-muted">N/A</span>`}
            </td>
            <td class="reviewed-status">
              ${reviewedStatus ? 
                `<span class="reviewed-yes">Yes</span>` : 
                `<span class="reviewed-no">No</span>`}
            </td>
            <td>
              <div class="btn-group" role="group">
                ${payment.payment_url ? 
                  `<a href="${payment.payment_url}" target="_blank" class="btn btn-sm btn-outline-primary action-btn">View</a>` : ''}
                <button class="btn btn-sm ${reviewedStatus ? 'btn-success' : 'btn-outline-secondary'} action-btn mark-reviewed-btn" 
                        onclick="markReviewed(${payment.record_id})"
                        ${reviewedStatus ? 'disabled' : ''}>
                  ${reviewedStatus ? 'Reviewed' : 'Review'}
                </button>
              </div>
            </td>
          `;
          
          // Add new row at the top
          if (tableBody.firstChild) {
            tableBody.insertBefore(newRow, tableBody.firstChild);
          } else {
            tableBody.appendChild(newRow);
          }
        }
      });
    }
    
    function updateRowData(row, payment) {
      // Update status_pay cell
      const statusPayCell = row.querySelector('td:nth-child(9)');
      if (statusPayCell) {
        const statusPayClass = `badge-${(payment.status_pay || 'pending').toLowerCase()}`;
        statusPayCell.innerHTML = `
          <span class="status-badge ${statusPayClass}">
            ${payment.status_pay || 'pending'}
          </span>
        `;
      }
      
      // Update status_url cell
      const statusUrlCell = row.querySelector('td:nth-child(10)');
      if (statusUrlCell) {
        if (payment.status_url) {
          const statusUrlClass = `badge-${payment.status_url.toLowerCase()}`;
          statusUrlCell.innerHTML = `
            <span class="status-badge ${statusUrlClass}">
              ${payment.status_url}
            </span>
          `;
        } else {
          statusUrlCell.innerHTML = '<span class="text-muted">N/A</span>';
        }
      }
      
      // Update reviewed cell
      const reviewedCell = row.querySelector('.reviewed-status');
      if (reviewedCell) {
        const reviewedStatus = payment.reviewed === 'yes' || payment.reviewed === 'Yes';
        reviewedCell.innerHTML = reviewedStatus ? 
          '<span class="reviewed-yes">Yes</span>' : 
          '<span class="reviewed-no">No</span>';
      }
      
      // Update reviewed button
      const reviewedBtn = row.querySelector('.mark-reviewed-btn');
      if (reviewedBtn) {
        const reviewedStatus = payment.reviewed === 'yes' || payment.reviewed === 'Yes';
        
        if (reviewedStatus) {
          reviewedBtn.textContent = 'Reviewed';
          reviewedBtn.classList.add('btn-success');
          reviewedBtn.classList.remove('btn-outline-secondary');
          reviewedBtn.disabled = true;
        } else {
          reviewedBtn.textContent = 'Review';
          reviewedBtn.classList.remove('btn-success');
          reviewedBtn.classList.add('btn-outline-secondary');
          reviewedBtn.disabled = false;
        }
      }
    }
    
    // Set up refresh interval
    setInterval(refreshDashboard, 30000); // Refresh every 30 seconds
  </script>
</body>
</html>----------------------------------------
-e 
=== File: /workspaces/mware3/views/admin/order-details.ejs
<!DOCTYPE html>
<html>
<head>
  <title>Order Details</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
    }
    
    .container-fluid {
      padding-left: 5%;
      padding-right: 5%;
      width: 100%;
      max-width: 100%;
    }
    
    .card-header { 
      background-color: #f8f9fa; 
      font-weight: bold; 
      padding: 12px 15px;
    }
    
    .status-completed { color: green; font-weight: bold; }
    .status-pending { color: orange; }
    .status-failed, .status-error { color: red; }
    .status-success { color: green; font-weight: bold; }
    .status-expired { color: #dc3545; }
    
    .order-detail-row { 
      margin-bottom: 12px;
      display: flex;
      flex-direction: row;
    }
    
    .detail-label { 
      font-weight: bold; 
      color: #495057;
      min-width: 140px;
      flex-shrink: 0;
    }
    
    .detail-value {
      flex-grow: 1;
    }
    
    /* Highlight important information */
    .highlight-box {
      background-color: #f8f9fa;
      border-left: 4px solid #0d6efd;
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 4px;
    }
    
    .highlight-date {
      border-left-color: #198754;
    }
    
    .highlight-address {
      border-left-color: #dc3545;
    }
    
    .highlight-message {
      border-left-color: #fd7e14;
    }
    
    .highlight-title {
      font-weight: bold;
      margin-bottom: 8px;
      color: #212529;
    }
    
    /* Status badges */
    .status-badge {
      padding: 3px 8px;
      border-radius: 12px;
      font-size: 0.8rem;
      font-weight: 500;
      display: inline-block;
      margin-bottom: 3px;
    }
    .badge-completed { background-color: #d1e7dd; color: #0f5132; }
    .badge-pending { background-color: #fff3cd; color: #664d03; }
    .badge-failed, .badge-error { background-color: #f8d7da; color: #842029; }
    .badge-expired { background-color: #f8d7da; color: #842029; }
    .badge-success { background-color: #d1e7dd; color: #0f5132; }
    
    /* Reviewed status styles */
    .reviewed-yes { 
      background-color: #d1e7dd; 
      color: #0f5132;
      border-radius: 12px;
      padding: 3px 8px;
      font-size: 0.8rem;
    }
    .reviewed-no { 
      background-color: #e2e3e5; 
      color: #41464b;
      border-radius: 12px;
      padding: 3px 8px;
      font-size: 0.8rem;
    }
    
    /* Data display card */
    .data-card {
      margin-bottom: 20px;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
    }
    
    /* JSON visualization */
    .json-data {
      background-color: #f8f9fa;
      padding: 10px;
      border-radius: 4px;
      font-family: monospace;
      white-space: pre-wrap;
      max-height: 300px;
      overflow-y: auto;
    }
    
    @media (max-width: 768px) {
      .container-fluid {
        padding-left: 15px;
        padding-right: 15px;
      }
      .order-detail-row {
        flex-direction: column;
      }
      .detail-label {
        margin-bottom: 4px;
      }
      .detail-value {
        padding-left: 0;
      }
    }
  </style>
</head>
<body>
  <div class="container-fluid mt-4">
    <div class="d-flex justify-content-between align-items-center mb-4">
      <h1>Order Details: <%= order.trade_order %></h1>
      <a href="/admin/payments" class="btn btn-outline-secondary">Back to Dashboard</a>
    </div>
    
    <!-- Critical Information Alert Box -->
    <div class="row mb-4">
      <div class="col-12">
        <% if (order.date_picker_order || order.time_picker_order) { %>
        <div class="highlight-box highlight-date">
          <div class="highlight-title">📅 Scheduled Visit</div>
          <div class="d-flex mb-2">
            <% if (order.date_picker_order) { %>
            <div class="me-4">
              <strong>Date:</strong> <%= order.date_picker_order %>
            </div>
            <% } %>
            <% if (order.time_picker_order) { %>
            <div>
              <strong>Time:</strong> <%= order.time_picker_order %>
            </div>
            <% } %>
          </div>
        </div>
        <% } %>
        
        <% if (order.address) { %>
        <div class="highlight-box highlight-address">
          <div class="highlight-title">📍 Delivery Address</div>
          <div><%= order.address %></div>
        </div>
        <% } %>
        
        <% if (order.message) { %>
        <div class="highlight-box highlight-message">
          <div class="highlight-title">💬 Customer Message</div>
          <div><%= order.message %></div>
        </div>
        <% } %>
      </div>
    </div>
    
    <div class="row">
      <div class="col-lg-6">
        <!-- Order Information Section -->
        <div class="data-card">
          <div class="card-header">Order Information</div>
          <div class="card-body">
            <div class="order-detail-row">
              <span class="detail-label">Order Number:</span>
              <span class="detail-value"><%= order.trade_order %></span>
            </div>
            <div class="order-detail-row">
              <span class="detail-label">Date:</span>
              <span class="detail-value"><%= new Date(order.order_creation_time).toLocaleString() %></span>
            </div>
            <div class="order-detail-row">
              <span class="detail-label">Total Amount:</span>
              <span class="detail-value">$<%= order.total_price %></span>
            </div>
            <% if (order.product_name_full) { %>
            <div class="order-detail-row">
              <span class="detail-label">Product:</span>
              <span class="detail-value"><%= order.product_name_full %></span>
            </div>
            <% } %>
            <% if (order.quantity) { %>
            <div class="order-detail-row">
              <span class="detail-label">Quantity:</span>
              <span class="detail-value"><%= order.quantity %></span>
            </div>
            <% } %>
            <% if (order.price_nzd) { %>
            <div class="order-detail-row">
              <span class="detail-label">Price (NZD):</span>
              <span class="detail-value">$<%= order.price_nzd %></span>
            </div>
            <% } %>
          </div>
        </div>
        
        <!-- Customer Information Section -->
        <div class="data-card">
          <div class="card-header">Customer Information</div>
          <div class="card-body">
            <div class="order-detail-row">
              <span class="detail-label">Name:</span>
              <span class="detail-value"><%= order.first_name_order %> <%= order.last_name_order %></span>
            </div>
            <div class="order-detail-row">
              <span class="detail-label">Email:</span>
              <span class="detail-value"><%= order.email_order %></span>
            </div>
            <% if (order.phone_order) { %>
            <div class="order-detail-row">
              <span class="detail-label">Phone:</span>
              <span class="detail-value"><%= order.phone_order %></span>
            </div>
            <% } %>
          </div>
        </div>
        
        <!-- Visit and Delivery Details -->
        <div class="data-card">
          <div class="card-header">Visit and Delivery Details</div>
          <div class="card-body">
            <% if (order.date_picker_order) { %>
            <div class="order-detail-row">
              <span class="detail-label">Visit Date:</span>
              <span class="detail-value"><strong><%= order.date_picker_order %></strong></span>
            </div>
            <% } %>
            <% if (order.time_picker_order) { %>
            <div class="order-detail-row">
              <span class="detail-label">Visit Time:</span>
              <span class="detail-value"><strong><%= order.time_picker_order %></strong></span>
            </div>
            <% } %>
            <% if (order.address) { %>
            <div class="order-detail-row">
              <span class="detail-label">Address:</span>
              <span class="detail-value"><strong><%= order.address %></strong></span>
            </div>
            <% } %>
            <% if (order.delivery) { %>
            <div class="order-detail-row">
              <span class="detail-label">Delivery Method:</span>
              <span class="detail-value"><%= order.delivery %></span>
            </div>
            <% } %>
            <% if (order.pay_in_person) { %>
            <div class="order-detail-row">
              <span class="detail-label">Pay In Person:</span>
              <span class="detail-value"><%= order.pay_in_person %></span>
            </div>
            <% } %>
          </div>
        </div>
        
        <!-- Additional Options -->
        <div class="data-card">
          <div class="card-header">Additional Options</div>
          <div class="card-body">
            <% if (order.checkbox_order) { %>
            <div class="order-detail-row">
              <span class="detail-label">Special Request:</span>
              <span class="detail-value"><%= order.checkbox_order %></span>
            </div>
            <% } %>
            <% if (order.message) { %>
            <div class="order-detail-row">
              <span class="detail-label">Customer Message:</span>
              <span class="detail-value"><strong><%= order.message %></strong></span>
            </div>
            <% } %>
            <% if (order.zoho_id) { %>
            <div class="order-detail-row">
              <span class="detail-label">Zoho ID:</span>
              <span class="detail-value"><%= order.zoho_id %></span>
            </div>
            <% } %>
          </div>
        </div>
        
        <!-- Technical Details (Collapsible) -->
        <div class="data-card">
          <div class="card-header" id="techDetailsHeader">
            <button class="btn btn-link p-0 text-decoration-none" type="button" data-bs-toggle="collapse" data-bs-target="#techDetailsCollapse" aria-expanded="false">
              Technical Details
            </button>
          </div>
          <div class="collapse" id="techDetailsCollapse">
            <div class="card-body">
              <% if (order.record_id) { %>
              <div class="order-detail-row">
                <span class="detail-label">Database ID:</span>
                <span class="detail-value"><%= order.record_id %></span>
              </div>
              <% } %>
              <% if (order.token) { %>
              <div class="order-detail-row">
                <span class="detail-label">Token:</span>
                <span class="detail-value"><small><code><%= order.token %></code></small></span>
              </div>
              <% } %>
            </div>
          </div>
        </div>
      </div>
      
      <div class="col-lg-6">
        <div class="data-card">
          <div class="card-header">Payment History</div>
          <div class="card-body">
            <% if (payments && payments.length > 0) { %>
              <div class="table-responsive">
                <table class="table table-striped">
                  <thead>
                    <tr>
                      <th>ID</th>
                      <th>Date</th>
                      <th>Provider</th>
                      <th>Amount</th>
                      <th>Status Pay</th>
                      <th>Status URL</th>
                      <th>Reviewed</th>
                    </tr>
                  </thead>
                  <tbody>
                    <% payments.forEach(payment => { %>
                      <tr>
                        <td><%= payment.record_id %></td>
                        <td><%= new Date(payment.created_at).toLocaleString() %></td>
                        <td><%= payment.provider %></td>
                        <td>$<%= parseFloat(payment.amount || 0).toFixed(2) %></td>
                        <td>
                          <span class="status-badge badge-<%= (payment.status_pay || 'pending').toLowerCase() %>">
                            <%= payment.status_pay || 'pending' %>
                          </span>
                        </td>
                        <td>
                          <% if (payment.status_url) { %>
                            <span class="status-badge badge-<%= payment.status_url.toLowerCase() %>">
                              <%= payment.status_url %>
                            </span>
                          <% } else { %>
                            <span class="text-muted">N/A</span>
                          <% } %>
                        </td>
                        <td>
                          <% if (payment.reviewed === 'yes' || payment.reviewed === 'Yes') { %>
                            <span class="reviewed-yes">Yes</span>
                          <% } else { %>
                            <span class="reviewed-no">No</span>
                          <% } %>
                        </td>
                      </tr>
                    <% }); %>
                  </tbody>
                </table>
              </div>
              
              <!-- Payment Details Accordions -->
              <div class="accordion mt-4" id="paymentAccordion">
                <% payments.forEach((payment, index) => { %>
                  <div class="accordion-item">
                    <h2 class="accordion-header" id="heading<%= index %>">
                      <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse<%= index %>" aria-expanded="false" aria-controls="collapse<%= index %>">
                        Payment #<%= payment.record_id %> - <%= payment.provider %> - $<%= parseFloat(payment.amount || 0).toFixed(2) %>
                      </button>
                    </h2>
                    <div id="collapse<%= index %>" class="accordion-collapse collapse" aria-labelledby="heading<%= index %>" data-bs-parent="#paymentAccordion">
                      <div class="accordion-body">
                        <div class="order-detail-row">
                          <span class="detail-label">Payment ID:</span>
                          <span class="detail-value"><%= payment.record_id %></span>
                        </div>
                        <div class="order-detail-row">
                          <span class="detail-label">Date:</span>
                          <span class="detail-value"><%= new Date(payment.created_at).toLocaleString() %></span>
                        </div>
                        <div class="order-detail-row">
                          <span class="detail-label">Provider:</span>
                          <span class="detail-value"><%= payment.provider %></span>
                        </div>
                        <div class="order-detail-row">
                          <span class="detail-label">Amount:</span>
                          <span class="detail-value">$<%= parseFloat(payment.amount || 0).toFixed(2) %></span>
                        </div>
                        <div class="order-detail-row">
                          <span class="detail-label">Payment Status:</span>
                          <span class="detail-value">
                            <span class="status-badge badge-<%= (payment.status_pay || 'pending').toLowerCase() %>">
                              <%= payment.status_pay || 'pending' %>
                            </span>
                          </span>
                        </div>
                        <div class="order-detail-row">
                          <span class="detail-label">URL Status:</span>
                          <span class="detail-value">
                            <% if (payment.status_url) { %>
                              <span class="status-badge badge-<%= payment.status_url.toLowerCase() %>">
                                <%= payment.status_url %>
                              </span>
                            <% } else { %>
                              <span class="text-muted">N/A</span>
                            <% } %>
                          </span>
                        </div>
                        <div class="order-detail-row">
                          <span class="detail-label">Reviewed:</span>
                          <span class="detail-value">
                            <% if (payment.reviewed === 'yes' || payment.reviewed === 'Yes') { %>
                              <span class="reviewed-yes">Yes</span>
                            <% } else { %>
                              <span class="reviewed-no">No</span>
                            <% } %>
                          </span>
                        </div>
                        <% if (payment.expires_at) { %>
                        <div class="order-detail-row">
                          <span class="detail-label">Expires:</span>
                          <span class="detail-value"><%= new Date(payment.expires_at).toLocaleString() %></span>
                        </div>
                        <% } %>
                        <% if (payment.status_expiry) { %>
                        <div class="order-detail-row">
                          <span class="detail-label">Expiry Status:</span>
                          <span class="detail-value"><%= payment.status_expiry %></span>
                        </div>
                        <% } %>
                        <% if (payment.payid) { %>
                        <div class="order-detail-row">
                          <span class="detail-label">Payment ID:</span>
                          <span class="detail-value"><%= payment.payid %></span>
                        </div>
                        <% } %>
                        <% if (payment.message_pay) { %>
                        <div class="order-detail-row">
                          <span class="detail-label">Message:</span>
                          <span class="detail-value"><%= payment.message_pay %></span>
                        </div>
                        <% } %>
                        <% if (payment.payment_url) { %>
                        <div class="order-detail-row">
                          <span class="detail-label">Payment URL:</span>
                          <span class="detail-value">
                            <a href="<%= payment.payment_url %>" target="_blank"><%= payment.payment_url %></a>
                          </span>
                        </div>
                        <% } %>
                        <% if (payment.status_url) { %>
                        <div class="order-detail-row">
                          <span class="detail-label">Status URL:</span>
                          <span class="detail-value">
                            <a href="<%= payment.status_url %>" target="_blank"><%= payment.status_url %></a>
                          </span>
                        </div>
                        <% } %>
                        <% if (payment.message_url) { %>
                        <div class="order-detail-row">
                          <span class="detail-label">Message URL:</span>
                          <span class="detail-value">
                            <a href="<%= payment.message_url %>" target="_blank"><%= payment.message_url %></a>
                          </span>
                        </div>
                        <% } %>
                      </div>
                    </div>
                  </div>
                <% }); %>
              </div>
            <% } else { %>
              <p class="text-muted">No payment records found for this order.</p>
            <% } %>
          </div>
        </div>
        
        <!-- Raw Order Data -->
        <div class="data-card">
          <div class="card-header">
            <button class="btn btn-link p-0 text-decoration-none" type="button" data-bs-toggle="collapse" data-bs-target="#rawDataCollapse" aria-expanded="false">
              Raw Order Data
            </button>
          </div>
          <div class="collapse" id="rawDataCollapse">
            <div class="card-body">
              <div class="json-data">
<%= JSON.stringify(order, null, 2) %>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>----------------------------------------
-e 
=== File: /workspaces/mware3/views/admin/error.ejs
<!DOCTYPE html>
<html>
<head>
  <title>Error</title>
</head>
<body>
  <h1>Error</h1>
  <p><%= error %></p>
</body>
</html>----------------------------------------

=== File: package.json ===
{
  "name": "mware3",
  "version": "1.0.0",
  "description": "Middleware for Webflow Integration",
  "main": "server.js",
  "engines": {
    "node": "20.18.1"
  },
  "scripts": {
    "start": "node server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "middleware",
    "webflow",
    "nodejs"
  ],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "axios": "^1.3.4",
    "bull": "^4.16.5",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "ejs": "^3.1.10",
    "express": "^4.18.2",
    "express-basic-auth": "^1.2.1",
    "express-rate-limit": "^7.5.0",
    "ioredis": "^5.5.0",
    "json2csv": "^6.0.0-alpha.2",
    "jsonwebtoken": "^9.0.0",
    "pg": "^8.10.0",
    "puppeteer": "^24.2.0",
    "winston": "^3.17.0"
  }
}
----------------------------------------
