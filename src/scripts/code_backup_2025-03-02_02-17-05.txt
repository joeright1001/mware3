Code Output Generated at UTC: 2025-03-02_02-17-05
Generated by: codespace
----------------------------------------

=== Directory Structure ===
.
├── config
│   ├── cors.js
│   └── database.js
├── routes
│   └── public
│       ├── orders.js
│       └── payments.js
├── scripts
│   ├── code_backup_2025-03-02_01-37-58.txt
│   ├── code_backup_2025-03-02_02-17-05.txt
│   ├── delete_old_code_backup_files.sh
│   ├── project_code_output.sh
│   └── sql_script.sql
└── services
    ├── expiry
    │   ├── expiryQueue.js
    │   ├── expiryService.js
    │   ├── providers
    │   │   └── blinkExpiry.js
    │   └── test-queue.js
    ├── orders
    │   └── orderService.js
    ├── payments
    │   ├── alipayService.js
    │   ├── blinkService.js
    │   ├── btcpayService.js
    │   ├── paymentService.js
    │   ├── paystatus
    │   │   ├── paymentStatusQueue.js
    │   │   ├── paymentStatusService.js
    │   │   └── providers
    │   │       └── poliPaymentStatus.js
    │   ├── poliService.js
    │   └── stripeService.js
    └── pdf
        └── pdfService.js

12 directories, 24 files
----------------------------------------

=== Database Schema ===
Attempting to connect to database...

=== Table: orders ===
                                                                         Table "public.orders"
       Column        |           Type           | Collation | Nullable |                        Default                        | Storage  | Stats target | Description 
---------------------+--------------------------+-----------+----------+-------------------------------------------------------+----------+--------------+-------------
 trade_order         | text                     |           |          |                                                       | extended |              | 
 first_name_order    | text                     |           | not null |                                                       | extended |              | 
 last_name_order     | text                     |           |          |                                                       | extended |              | 
 email_order         | text                     |           |          |                                                       | extended |              | 
 phone_order         | text                     |           |          |                                                       | extended |              | 
 product_name_full   | text                     |           |          |                                                       | extended |              | 
 total_price         | text                     |           |          |                                                       | extended |              | 
 quantity            | text                     |           |          |                                                       | extended |              | 
 price_nzd           | text                     |           |          |                                                       | extended |              | 
 zoho_id             | text                     |           |          |                                                       | extended |              | 
 delivery            | text                     |           |          |                                                       | extended |              | 
 pay_in_person       | text                     |           |          |                                                       | extended |              | 
 checkbox_order      | text                     |           |          |                                                       | extended |              | 
 address             | text                     |           |          |                                                       | extended |              | 
 message             | text                     |           |          |                                                       | extended |              | 
 token               | text                     |           |          |                                                       | extended |              | 
 date_picker_order   | text                     |           |          |                                                       | extended |              | 
 time_picker_order   | text                     |           |          |                                                       | extended |              | 
 record_id           | integer                  |           | not null | nextval('orders_record_id_seq'::regclass)             | plain    |              | 
 order_creation_time | timestamp with time zone |           |          | timezone('Pacific/Auckland'::text, CURRENT_TIMESTAMP) | plain    |              | 
Indexes:
    "orders_pkey" PRIMARY KEY, btree (record_id)
Access method: heap

----------------------------------------

=== Table: payments ===
                                                                  Table "public.payments"
     Column      |            Type             | Collation | Nullable |                   Default                   | Storage  | Stats target | Description 
-----------------+-----------------------------+-----------+----------+---------------------------------------------+----------+--------------+-------------
 record_id       | integer                     |           | not null | nextval('payments_record_id_seq'::regclass) | plain    |              | 
 order_record_id | integer                     |           |          |                                             | plain    |              | 
 created_at      | timestamp without time zone |           |          | CURRENT_TIMESTAMP                           | plain    |              | 
 provider        | character varying(50)       |           | not null |                                             | extended |              | 
 amount          | numeric(10,2)               |           | not null |                                             | main     |              | 
 status_url      | text                        |           |          |                                             | extended |              | 
 message_url     | text                        |           |          |                                             | extended |              | 
 payment_url     | text                        |           |          |                                             | extended |              | 
 status_pay      | character varying(50)       |           |          |                                             | extended |              | 
 message_pay     | text                        |           |          |                                             | extended |              | 
 payid           | character varying(255)      |           |          |                                             | extended |              | 
 expires_at      | timestamp with time zone    |           |          |                                             | plain    |              | 
 status_expiry   | text                        |           |          |                                             | extended |              | 
Indexes:
    "payments_pkey" PRIMARY KEY, btree (record_id)
Referenced by:
    TABLE "expiry" CONSTRAINT "expiry_payments_record_id_fkey" FOREIGN KEY (payments_record_id) REFERENCES payments(record_id)
    TABLE "pay_status" CONSTRAINT "pay_status_payments_record_id_fkey" FOREIGN KEY (payments_record_id) REFERENCES payments(record_id)
Access method: heap

----------------------------------------
----------------------------------------

=== File: /workspaces/mware3/server.js ===
/**
 * Main Application Entry Point
 * --------------------------
 * Purpose: Initializes and configures the Express application
 * Role: Sets up middleware, routes, and starts the server
 * 
 * Key Components:
 * 1. Environment variables loading
 * 2. CORS configuration
 * 3. Route registration
 * 4. Server initialization
 * 
 * Dependencies:
 * - dotenv for environment variables
 * - express for web server
 * - cors for Cross-Origin Resource Sharing
 * 
 * IMPORTANT CONFIGURATIONS:
 * - PORT in .env file (defaults to 3000)
 * - Ensure all required environment variables are set in .env:
 *   - DATABASE_URL
 *   - JWT_SECRET
 *   - PORT (optional)
 */

require("dotenv").config();
const express = require("express");
const cors = require("cors");

// Import configurations
const corsOptions = require('./src/config/cors');

// Import routes
const orderRoutes = require('./src/routes/public/orders');
const paymentRoutes = require('./src/routes/public/payments'); // Add this line

// Debug: Log environment variables
console.log('Environment:', {
    PORT: process.env.PORT,
    DATABASE_URL: process.env.DATABASE_URL ? 'Set' : 'Not Set',
    JWT_SECRET: process.env.JWT_SECRET ? 'Set' : 'Not Set',
    POLI_AUTH_CODE: process.env.POLI_AUTH_CODE ? 'Set' : 'Not Set'
});

// Debug: Log configurations
console.log('Loaded configurations:', {
    corsOptions,
    orderRoutes: typeof orderRoutes,
    paymentRoutes: typeof paymentRoutes
});

const app = express();

// Trust proxy setting for rate limiting
app.set('trust proxy', 1);

// Middleware
app.use(cors(corsOptions));
app.use(express.json());

console.log('Middleware initialized');

// Routes
app.use("/", orderRoutes);      // Base URL for order routes
app.use("/api", paymentRoutes); // Payment status endpoint

// Error handling middleware
app.use((err, req, res, next) => {
    console.error('Global error:', err);
    res.status(500).json({ error: "Server error" });
});

// ⚠️ CONFIGURE: Server port
const PORT = process.env.PORT || 3000;

// CRITICAL: Create server this way to handle shutdown
const server = app.listen(PORT, () => {
    console.log(`🚀 Server running on port ${PORT}`);
});

// Graceful Shutdown Handler
function gracefulShutdown() {
    console.log('Received kill signal, shutting down gracefully');
    server.close(() => {
        console.log('Closed out remaining connections');
        process.exit(0);
    });
    
    // Force close after 10 seconds
    setTimeout(() => {
        console.error('Could not close connections in time, forcefully shutting down');
        process.exit(1);
    }, 10000);
}

// Handle shutdown signals
process.on('SIGTERM', gracefulShutdown);
process.on('SIGINT', gracefulShutdown);

// Add basic health check endpoint
app.get('/health', (req, res) => {
    res.json({ status: 'ok', timestamp: new Date().toISOString() });
});----------------------------------------

=== File: /workspaces/mware3/.env ===
# Database Configuration
DATABASE_URL=postgres://postgres:********@localhost:5432/railway_dev

# Security
JWT_SECRET=**********************

# POLi Payment Integration
POLI_AUTH_CODE=**********************
POLI_API_URL=https://poliapi.uat3.paywithpoli.com/api/POLiLink/Create

# CORS Configuration
CORS_ORIGIN=https://gold-buyers-christchurch-test.webflow.io

# Database Connection Details (extracted from DATABASE_URL)
DB_HOST=localhost
DB_PORT=5432
DB_NAME=railway_dev
DB_USER=postgres
DB_PASSWORD=********

BLINK_CLIENT_ID=uJlIlsU0bLYc86N3zBpZZqpptgdlZ5sk
BLINK_CLIENT_SECRET=9XisL8Q0_89MUTyyTP0_AzbenEQ5fF7-8vgemVxrxmpO_5EOR8B4nEpH2if_5XWp

BLINK_API_BASE_URL=https://sandbox.debit.blinkpay.co.nz/payments/v1
BLINK_AUTH_URL=https://sandbox.debit.blinkpay.co.nz/oauth2/token
BLINK_REDIRECT_URL=https://gold-buyers-christchurch.webflow.io/

BLINK_PAYMENT_EXPIRY_MINUTES=30
REDIS_URL=redis://localhost:6379

BTCPAY_API_URL=https://btcpay.canterburygold.co.nz
BTCPAY_API_KEY=93a2787029a386c85ef6f174e7bc71c211ee9d74
BTCPAY_STORE_ID=BBBSsTabQGXnK3FhJAHVrygBN1gFPC5tfeUWrPWRFZHP
BTCPAY_REDIRECT_URL=https://gold-buyers-christchurch.webflow.io/

STRIPE_BASE_URL=https://api.stripe.com
STRIPE_PUBLISHABLE_KEY=pk_test_51Qv6w4R50uNdu8Yp0pzgpGaetorJpmgYWqDGXztPkRbaBQ1zI3jh6OKAeITqCkr8aPqvuoP0JTuRcxYwb8kYXHWf00tP2l274h
STRIPE_SECRET_KEY=sk_test_51Qv6w4R50uNdu8Yp2nOjV2WWSmQgUgVklyvNhAjitxt9vQYRiMUUrrapfOx8rfA22Ysdv0i3q5yHmW6sACLcSTBa00NS0fPrIA
STRIPE_LOCAL_FEE=0.027
STRIPE_SUCCESS_URL=https://gold-buyers-christchurch.webflow.io/
STRIPE_CANCEL_URL=https://gold-buyers-christchurch.webflow.io/
STRIPE_ALIPAY_FEE=0.03

----------------------------------------
-e 
=== File: /workspaces/mware3/src/routes/public/orders.js
/**
 * Order Routes
 * -----------
 * Purpose: Defines all HTTP endpoints related to orders
 * Role: Handles HTTP requests and delegates business logic to OrderService
 * 
 * Current Endpoints:
 * POST /create - Creates a new order
 * 
 * Dependencies:
 * - OrderService for business logic
 * - Express Router for routing
 * 
 * Error Handling:
 * - 400 for validation errors
 * - 500 for server errors
 */

const express = require('express');
const router = express.Router();
const OrderService = require('../../services/orders/orderService');

router.post("/create", async (req, res) => {
    try {
        const result = await OrderService.createOrder(req.body);
        res.json(result);
    } catch (error) {
        console.error("Order creation error:", error);
        res.status(error.message.includes("required") ? 400 : 500)
           .json({ error: error.message || "Failed to create order" });
    }
});

module.exports = router;----------------------------------------
-e 
=== File: /workspaces/mware3/src/routes/public/payments.js
/**
 * Payment Routes
 * -------------
 * Purpose: Handles payment status checking endpoints
 * Role: Provides API for checking payment URL status
 * 
 * Endpoints:
 * GET /api/payment-status/:token - Check payment URL status
 * 
 * Dependencies:
 * - PaymentService for business logic
 * - Express Router for routing
 * 
 * Error Handling:
 * - 400 for validation errors
 * - 500 for server errors
 */

const express = require('express');
const router = express.Router();
const PaymentService = require('../../services/payments/paymentService');
const rateLimit = require('express-rate-limit');

// Rate limiting: 60 requests per minute
const statusLimiter = rateLimit({
    windowMs: 60 * 1000,
    max: 60,
    message: { error: 'Too many requests, please try again later' }
});

router.get("/payment-status/:token", statusLimiter, async (req, res) => {
    try {
        console.log(`Checking payment status for token: ${req.params.token}`);
        const result = await PaymentService.getStatusByToken(req.params.token);
        res.json(result);
    } catch (error) {
        console.error("Payment status check error:", error);
        res.status(400).json({ 
            error: error.message || "Failed to check payment status" 
        });
    }
});

module.exports = router;----------------------------------------
-e 
=== File: /workspaces/mware3/src/config/cors.js
/**
 * CORS Configuration
 * -----------------
 * Purpose: Defines Cross-Origin Resource Sharing (CORS) settings
 * Role: Controls which domains can access your API
 * 
 * IMPORTANT CONFIGURATION:
 * - origin: Change this URL when deploying to different environments
 * - methods: HTTP methods allowed
 * - allowedHeaders: Headers clients can send
 */

const corsOptions = {
    origin: process.env.CORS_ORIGIN,
    methods: "GET,POST,OPTIONS",
    allowedHeaders: "Content-Type",
    credentials: true
};

module.exports = corsOptions;----------------------------------------
-e 
=== File: /workspaces/mware3/src/config/database.js
/**
 * Database Configuration
 * ---------------------
 * Purpose: Centralizes database connection configuration
 * Role: Provides a single connection pool instance used throughout the application
 * 
 * Dependencies:
 * - pg (PostgreSQL client)
 * - DATABASE_URL environment variable
 * 
 * IMPORTANT CONFIGURATION:
 * The DATABASE_URL should be set in your .env file with format:
 * postgresql://username:password@host:port/database
 */

const { Pool } = require("pg");

const pool = new Pool({ 
    connectionString: process.env.DATABASE_URL 
});

module.exports = pool;----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/pdf/pdfService.js
/**
 * PDF Generation Service
 * ---------------------
 * Purpose: Handles PDF generation for order confirmations
 * Role: Creates PDFs from order data using Puppeteer
 * 
 * Dependencies:
 * - puppeteer for PDF generation
 * - Requires Chrome/Chromium to be installed in the environment
 */

const puppeteer = require('puppeteer');

class PDFService {
    async generateOrderPDF(orderData) {
        const browser = await puppeteer.launch({
            args: ['--no-sandbox', '--disable-setuid-sandbox'],
            headless: 'new'  // Using new headless mode
        });

        try {
            const page = await browser.newPage();
            
            // TODO: Replace with your actual order page URL
            // await page.goto('https://your-webflow-print-page-url');
            
            // TODO: Add logic to populate order data
            
            const pdf = await page.pdf({
                format: 'A4',
                printBackground: true
            });

            return pdf;
        } finally {
            await browser.close();
        }
    }
}

module.exports = new PDFService();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/poliService.js
/**
 * POLi Payment Service Integration
 * 
 * This service handles the integration with POLi payment gateway for processing payments
 * in New Zealand. It provides functionality to generate payment links and handle payment
 * transactions through the POLi API.
 * 
 * Key Features:
 * - Generates payment links with 30-minute expiry
 * - Handles NZ timezone specific formatting
 * - Stores payment records in database
 * - Error handling and logging
 * 
 * Flow:
 * 1. Receives order data
 * 2. Generates expiry timestamp in NZ timezone
 * 3. Creates POLi API payload
 * 4. Makes API request to generate payment link
 * 5. Stores payment record in database
 * 
 * Requirements:
 * - POLi API credentials in environment variables
 * - PostgreSQL database connection
 * - Axios for HTTP requests
 */


const axios = require('axios');
const pool = require('../../config/database');

class PoliService {
    /**
     * Generates a payment link through POLi API
     * @param {Object} orderData - Contains order details including total_price and trade_order
     * @returns {String} Payment URL for redirect
     */
    async generatePaymentLink(orderData) {
        try {
            console.log('\n=== POLi Payment Processing ===');
            console.log('Generating POLi payment link for order:', orderData.trade_order);

            // Calculate expiry time 30 minutes from now
            const date = new Date();
            const futureDate = new Date(date.getTime() + (30 * 60 * 1000));
            
            // Format with New Zealand timezone (UTC+13)
            const formattedExpiry = futureDate.toLocaleString('en-NZ', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                timeZone: 'Pacific/Auckland',
                hour12: false
            }).replace(/(\d{2})\/(\d{2})\/(\d{4}), (\d{2}):(\d{2}):(\d{2})/, '$3-$2-$1T$4:$5:$6+13:00');

            console.log('POLi Generated Expiry Time:', formattedExpiry);

            // Construct payload for POLi API
            const payload = {
                LinkType: "0",
                Amount: orderData.total_price.toString(),
                MerchantReference: orderData.trade_order,
                LinkExpiry: formattedExpiry
            };

            console.log('POLi API Payload:', JSON.stringify(payload));

            // Make API request to POLi
            const response = await axios.post(
                process.env.POLI_API_URL,
                payload,
                {
                    headers: {
                        'Authorization': `Basic ${process.env.POLI_AUTH_CODE}`,
                        'Content-Type': 'application/json'
                    }
                }
            );

            // Process response and remove quotes
            const paymentUrl = response.data.replace(/"/g, '');
            console.log('POLi API Response:', paymentUrl);

            // Store successful payment record in database
            await pool.query(
                `INSERT INTO payments (order_record_id, provider, status_url, amount, payment_url) 
                 VALUES ($1, $2, $3, $4, $5)`,
                [orderData.record_id, 'POLi', 'success', orderData.total_price, paymentUrl]
            );

            return paymentUrl;

        } catch (error) {
            console.error('\n=== POLi API Error ===');
            console.error('Error details:', {
                message: error.message,
                response: error.response?.data,
                order: orderData.trade_order
            });
            
            // Store failed payment record in database
            await pool.query(
                `INSERT INTO payments (order_record_id, provider, status_url, amount, message_url) 
                 VALUES ($1, $2, $3, $4, $5)`,
                [orderData.record_id, 'POLi', 'failed', orderData.total_price, 
                 error.response?.data?.ErrorMessage || error.message]
            );
            throw error;
        }
    }
}

module.exports = new PoliService();



----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/stripeService.js
/**
 * Stripe Payment Service Integration
 * --------------------------------
 * Purpose: Handles Stripe Checkout Session creation for payment processing
 * 
 * Features:
 * - Creates one-time payment links using Stripe Checkout
 * - Supports single payments without inventory management
 * - 30-minute expiry on payment links
 * - Calculates fees (2.7% + $0.30)
 * - New Zealand specific restrictions
 * 
 * Required Environment Variables:
 * - STRIPE_SECRET_KEY: Stripe API secret key
 * - STRIPE_BASE_URL: Base URL for Stripe API
 * - STRIPE_LOCAL_FEE: Local fee percentage (e.g., 0.027 for 2.7%)
 * - STRIPE_SUCCESS_URL: Success redirect URL
 * - STRIPE_CANCEL_URL: Cancel redirect URL
 */

const axios = require('axios');
const pool = require('../../config/database');

class StripeService {
    constructor() {
        this.secretKey = process.env.STRIPE_SECRET_KEY;
        this.baseUrl = process.env.STRIPE_BASE_URL;
        this.feePercentage = parseFloat(process.env.STRIPE_LOCAL_FEE) || 0.027;
        this.fixedFee = 0.30; // Fixed fee in dollars
        this.successUrl = process.env.STRIPE_SUCCESS_URL;
        this.cancelUrl = process.env.STRIPE_CANCEL_URL;

        // Validate configuration
        const requiredEnvVars = [
            'STRIPE_SECRET_KEY',
            'STRIPE_BASE_URL',
            'STRIPE_SUCCESS_URL',
            'STRIPE_CANCEL_URL'
        ];

        const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);
        if (missingVars.length > 0) {
            console.warn('Missing Stripe configuration:', missingVars.join(', '));
        }
    }

    /**
     * Calculates total amount including Stripe fees
     * Formula: (base amount + 0.30) / (1 - 0.027)
     * @param {number} baseAmount - Original amount before fees
     * @returns {number} Total amount including fees
     */
    calculateTotalWithFees(baseAmount) {
        const amount = parseFloat(baseAmount);
        return (amount + this.fixedFee) / (1 - this.feePercentage);
    }

    /**
     * Generates a Stripe Checkout Session payment link
     * @param {Object} orderData - Order information including amount and reference
     * @returns {String} Checkout session URL
     */
    async generatePaymentLink(orderData) {
        try {
            console.log('\n=== Stripe Payment Processing ===');
            console.log('Generating Stripe payment link for order:', orderData.trade_order);

            // Calculate total amount including fees
            const baseAmount = parseFloat(orderData.total_price);
            const totalWithFees = this.calculateTotalWithFees(baseAmount);
            
            // Convert to cents for Stripe
            const amountInCents = Math.round(totalWithFees * 100);

            console.log('Payment calculation:', {
                baseAmount,
                feePercentage: this.feePercentage,
                fixedFee: this.fixedFee,
                totalWithFees,
                amountInCents
            });

            const payload = {
                mode: 'payment',
                success_url: this.successUrl,
                cancel_url: this.cancelUrl,
                currency: 'nzd',
                payment_method_types: ['card'],
                
                billing_address_collection: 'required',
                shipping_address_collection: {
                    allowed_countries: ['NZ']
                },

                line_items: [{
                    price_data: {
                        currency: 'nzd',
                        product_data: {
                            name: orderData.product_name_full || 'Gold Purchase',
                            description: `Order: ${orderData.trade_order} (Includes processing fee)`
                        },
                        unit_amount: amountInCents
                    },
                    quantity: 1
                }],

                customer_email: orderData.email_order || undefined,
                client_reference_id: orderData.trade_order,
                expires_at: Math.floor(Date.now() / 1000) + (30 * 60)
            };

            const response = await axios.post(
                `${this.baseUrl}/v1/checkout/sessions`,
                payload,
                {
                    headers: {
                        'Authorization': `Bearer ${this.secretKey}`,
                        'Content-Type': 'application/x-www-form-urlencoded'
                    }
                }
            );

            console.log('Stripe Checkout Session created:', response.data.id);

            if (response.data && response.data.url) {
                // Store payment record with original amount (not including fees)
                await pool.query(
                    `INSERT INTO payments (
                        order_record_id, provider, status_url, amount, 
                        payment_url, payid, expires_at
                    ) VALUES ($1, $2, $3, $4, $5, $6, NOW() + interval '30 minutes')`,
                    [
                        orderData.record_id,
                        'STRIPE',
                        'success',
                        orderData.total_price, // Store original amount
                        response.data.url,
                        response.data.id
                    ]
                );

                return response.data.url;
            } else {
                throw new Error('Invalid response from Stripe');
            }

        } catch (error) {
            console.error('\n=== Stripe API Error ===');
            console.error('Error details:', {
                message: error.message,
                response: error.response?.data,
                order: orderData.trade_order
            });

            // Store failed payment record
            await pool.query(
                `INSERT INTO payments (
                    order_record_id, provider, status_url, amount, message_url
                ) VALUES ($1, $2, $3, $4, $5)`,
                [
                    orderData.record_id,
                    'STRIPE',
                    'failed',
                    orderData.total_price,
                    error.response?.data?.error?.message || error.message
                ]
            );

            throw error;
        }
    }
}

module.exports = new StripeService();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/paystatus/providers/poliPaymentStatus.js
----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/paystatus/paymentStatusQueue.js
----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/paystatus/paymentStatusService.js
----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/blinkService.js
/**
 * Blink Payment Service Integration
 * 
 * This service handles the integration with Blink Debit payment gateway.
 * Uses OAuth2 client credentials flow for authentication.
 * 
 * Required Environment Variables:
 * - BLINK_CLIENT_ID: OAuth2 client ID
 * - BLINK_CLIENT_SECRET: OAuth2 client secret
 * - BLINK_API_BASE_URL: Base URL for Blink API (e.g., https://sandbox.debit.blinkpay.co.nz/payments/v1)
 * - BLINK_AUTH_URL: Authentication endpoint (e.g., https://sandbox.debit.blinkpay.co.nz/oauth2/token)
 * - BLINK_REDIRECT_URL: Redirect URL after payment (e.g., https://your-domain.com)
 * - BLINK_PAYMENT_EXPIRY_MINUTES: Minutes until payment link expires (default: 30)
 */

const axios = require('axios');
const pool = require('../../config/database');
const crypto = require('crypto');
const expiryService = require('../expiry/expiryService');

class BlinkService {
    constructor() {
        // Initialize configuration from environment variables
        this.CLIENT_ID = process.env.BLINK_CLIENT_ID;
        this.CLIENT_SECRET = process.env.BLINK_CLIENT_SECRET;
        this.BASE_URL = process.env.BLINK_API_BASE_URL;
        this.AUTH_URL = process.env.BLINK_AUTH_URL;
        this.REDIRECT_URL = process.env.BLINK_REDIRECT_URL;
        
        // Token management
        this.accessToken = null;
        this.tokenExpiry = null;

        // Initialize expiry service
        this.expiryService = expiryService;

        // Configuration validation
        const requiredEnvVars = [
            'BLINK_CLIENT_ID',
            'BLINK_CLIENT_SECRET',
            'BLINK_API_BASE_URL',
            'BLINK_AUTH_URL',
            'BLINK_REDIRECT_URL',
            'BLINK_PAYMENT_EXPIRY_MINUTES'
        ];

        const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);
        if (missingVars.length > 0) {
            console.error('Missing required environment variables:', missingVars.join(', '));
            throw new Error('Missing required environment variables for Blink integration');
        }
    }

    // [Previous methods remain exactly the same: getAccessToken, ensureValidToken]
    async getAccessToken() {
        try {
            console.log('\n=== Blink Authentication ===');
            console.log('Requesting Blink access token...');
            
            const payload = {
                client_id: this.CLIENT_ID,
                client_secret: this.CLIENT_SECRET,
                grant_type: 'client_credentials',
                audience: 'https://api.blinkdebit.co.nz'
            };

            const response = await axios.post(
                this.AUTH_URL,
                payload,
                {
                    headers: {
                        'Content-Type': 'application/json'
                    }
                }
            );

            this.accessToken = response.data.access_token;
            this.tokenExpiry = Date.now() + (response.data.expires_in * 1000);
            
            console.log('Successfully obtained Blink access token');
            return this.accessToken;
        } catch (error) {
            console.error('Failed to get Blink access token:', error.response?.data || error.message);
            throw error;
        }
    }

    async ensureValidToken() {
        if (!this.accessToken || !this.tokenExpiry || Date.now() >= this.tokenExpiry - 60000) {
            await this.getAccessToken();
        }
        return this.accessToken;
    }

    async generatePaymentLink(orderData) {
        try {
            console.log('\n=== Blink Payment Processing ===');
            console.log('Generating Blink payment link for order:', orderData.trade_order);

            const token = await this.ensureValidToken();

            const formattedAmount = typeof orderData.total_price === 'string' 
                ? parseFloat(orderData.total_price).toFixed(2)
                : orderData.total_price.toFixed(2);

            const payload = {
                flow: {
                    detail: {
                        type: "gateway",
                        redirect_uri: this.REDIRECT_URL,
                        flow_hint: {
                            type: "redirect",
                            bank: "PNZ"
                        }
                    }
                },
                pcr: {
                    particulars: orderData.trade_order.substring(0, 12).replace(/[^a-zA-Z0-9- &#?:_\/,.']/g, ''),
                    code: orderData.trade_order.substring(0, 12).replace(/[^a-zA-Z0-9- &#?:_\/,.']/g, ''),
                    reference: orderData.record_id.toString().substring(0, 12)
                },
                amount: {
                    total: formattedAmount,
                    currency: "NZD"
                }
            };

            console.log('Blink API Payload:', JSON.stringify(payload));

            const headers = {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                'request-id': crypto.randomUUID(),
                'x-correlation-id': crypto.randomUUID(),
                'idempotency-key': crypto.randomUUID()
            };

            const response = await axios.post(
                `${this.BASE_URL}/quick-payments`,
                payload,
                {
                    headers: headers,
                    timeout: 10000
                }
            );

            console.log('Blink API Response:', response.data);

            if (response.data && response.data.redirect_uri) {
                await pool.query(
                    `INSERT INTO payments (
                        order_record_id, provider, status_url, amount, 
                        payment_url, payid, expires_at
                    ) VALUES ($1, $2, $3, $4, $5, $6, NOW() + interval '${process.env.BLINK_PAYMENT_EXPIRY_MINUTES} minutes')`,
                    [
                        orderData.record_id, 
                        'BLINK', 
                        'success', 
                        formattedAmount, 
                        response.data.redirect_uri,
                        response.data.quick_payment_id
                    ]
                );

                // Schedule payment expiry
                await this.expiryService.scheduleExpiry(
                    response.data.quick_payment_id,
                    'BLINK'
                );

                return response.data.redirect_uri;
            } else {
                throw new Error('No redirect_uri in response');
            }

        } catch (error) {
            console.error('\n=== Blink API Error ===');
            console.error('Error details:', {
                message: error.message,
                response: error.response?.data,
                status: error.response?.status,
                headers: error.response?.headers,
                order: orderData.trade_order
            });
            
            await pool.query(
                `INSERT INTO payments (order_record_id, provider, status_url, amount, message_url) 
                 VALUES ($1, $2, $3, $4, $5)`,
                [orderData.record_id, 'BLINK', 'failed', orderData.total_price, 
                 error.response?.data?.detail || error.message]
            );
            
            console.error('Blink payment link generation failed for order:', orderData.trade_order);
            throw error;
        }
    }
}

module.exports = new BlinkService();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/alipayService.js
/**
 * Alipay Service Integration (via Stripe)
 * -------------------------------------
 * Purpose: Handles Alipay-specific payment processing through Stripe Checkout
 * 
 * Features:
 * - Creates Alipay-only payment links using Stripe Checkout
 * - Implements 3% processing fee for Alipay transactions
 * - Restricts payment method to Alipay only
 * - Supports CNY currency for Alipay transactions
 * 
 * Environment Variables:
 * - STRIPE_SECRET_KEY: Stripe API secret key
 * - STRIPE_BASE_URL: Base URL for Stripe API
 * - STRIPE_ALIPAY_FEE: Alipay processing fee (e.g., 0.03 for 3%)
 * - STRIPE_SUCCESS_URL: Success redirect URL
 * - STRIPE_CANCEL_URL: Cancel redirect URL
 */

const axios = require('axios');
const pool = require('../../config/database');

class AlipayService {
    constructor() {
        this.secretKey = process.env.STRIPE_SECRET_KEY;
        this.baseUrl = process.env.STRIPE_BASE_URL;
        this.feePercentage = parseFloat(process.env.STRIPE_ALIPAY_FEE) || 0.03;
        this.successUrl = process.env.STRIPE_SUCCESS_URL;
        this.cancelUrl = process.env.STRIPE_CANCEL_URL;

        // Validate configuration
        const requiredEnvVars = [
            'STRIPE_SECRET_KEY',
            'STRIPE_BASE_URL',
            'STRIPE_SUCCESS_URL',
            'STRIPE_CANCEL_URL',
            'STRIPE_ALIPAY_FEE'
        ];

        const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);
        if (missingVars.length > 0) {
            console.warn('Missing Alipay configuration:', missingVars.join(', '));
        }
    }

    /**
     * Calculates total amount including Alipay processing fee
     * @param {number} baseAmount - Original amount before fees
     * @returns {number} Total amount including fees
     */
    calculateTotalWithFees(baseAmount) {
        const amount = parseFloat(baseAmount);
        return amount * (1 + this.feePercentage);
    }

    /**
     * Generates an Alipay-only payment link via Stripe
     * @param {Object} orderData - Order information including amount and reference
     * @returns {String} Checkout session URL
     */
    async generatePaymentLink(orderData) {
        try {
            console.log('\n=== Alipay Payment Processing ===');
            console.log('Generating Alipay payment link for order:', orderData.trade_order);

            // Calculate total amount including Alipay fee
            const baseAmount = parseFloat(orderData.total_price);
            const totalWithFees = this.calculateTotalWithFees(baseAmount);
            const amountInCents = Math.round(totalWithFees * 100);

            console.log('Alipay payment calculation:', {
                baseAmount,
                feePercentage: this.feePercentage,
                totalWithFees,
                amountInCents
            });

            const payload = {
                mode: 'payment',
                success_url: this.successUrl,
                cancel_url: this.cancelUrl,
                payment_method_types: ['alipay'],
                currency: 'nzd',

                line_items: [{
                    price_data: {
                        currency: 'nzd',
                        product_data: {
                            name: orderData.product_name_full || 'Gold Purchase',
                            description: `Order: ${orderData.trade_order} (Includes Alipay fee)`
                        },
                        unit_amount: amountInCents
                    },
                    quantity: 1
                }],

                customer_email: orderData.email_order || undefined,
                client_reference_id: orderData.trade_order,
                expires_at: Math.floor(Date.now() / 1000) + (30 * 60)
            };

            const response = await axios.post(
                `${this.baseUrl}/v1/checkout/sessions`,
                payload,
                {
                    headers: {
                        'Authorization': `Bearer ${this.secretKey}`,
                        'Content-Type': 'application/x-www-form-urlencoded'
                    }
                }
            );

            console.log('Alipay Checkout Session created:', response.data.id);

            if (response.data && response.data.url) {
                // Store payment record
                await pool.query(
                    `INSERT INTO payments (
                        order_record_id, provider, status_url, amount, 
                        payment_url, payid, expires_at
                    ) VALUES ($1, $2, $3, $4, $5, $6, NOW() + interval '30 minutes')`,
                    [
                        orderData.record_id,
                        'ALIPAY',
                        'success',
                        orderData.total_price,
                        response.data.url,
                        response.data.id
                    ]
                );

                return response.data.url;
            } else {
                throw new Error('Invalid response from Stripe for Alipay');
            }

        } catch (error) {
            console.error('\n=== Alipay API Error ===');
            console.error('Error details:', {
                message: error.message,
                response: error.response?.data,
                order: orderData.trade_order
            });

            // Store failed payment record
            await pool.query(
                `INSERT INTO payments (
                    order_record_id, provider, status_url, amount, message_url
                ) VALUES ($1, $2, $3, $4, $5)`,
                [
                    orderData.record_id,
                    'ALIPAY',
                    'failed',
                    orderData.total_price,
                    error.response?.data?.error?.message || error.message
                ]
            );

            throw error;
        }
    }
}

module.exports = new AlipayService();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/btcpayService.js
/**
 * BTCPay Server Payment Integration
 */

const axios = require('axios');
const pool = require('../../config/database');

class BTCPayService {
    constructor() {
        // Remove trailing slash if present in API URL
        this.API_URL = process.env.BTCPAY_API_URL?.replace(/\/$/, '');
        this.API_KEY = process.env.BTCPAY_API_KEY;
        this.STORE_ID = process.env.BTCPAY_STORE_ID;

        // Validate configuration
        if (!this.API_URL || !this.API_KEY || !this.STORE_ID) {
            console.warn('BTCPay Server configuration incomplete');
        }
    }

    async generatePaymentLink(orderData) {
        try {
            console.log('\n=== BTCPay Payment Processing ===');
            console.log('Generating BTCPay invoice for order:', orderData.trade_order);

            // Format amount properly
            const formattedAmount = typeof orderData.total_price === 'string' 
                ? parseFloat(orderData.total_price).toFixed(2)
                : orderData.total_price.toFixed(2);

            const payload = {
                metadata: {
                    orderId: orderData.trade_order,
                    buyerName: orderData.first_name_order,
                    buyerEmail: orderData.email_order,
                    itemDesc: orderData.product_name_full || 'Gold Purchase'
                },
                amount: formattedAmount,
                currency: "NZD",
                checkout: {
                    speedPolicy: "MediumSpeed",
                    paymentMethods: ["BTC"],
                    redirectURL: process.env.BTCPAY_REDIRECT_URL,
                    defaultLanguage: "en"
                }
            };

            console.log('BTCPay request configuration:', {
                url: `${this.API_URL}/api/v1/stores/${this.STORE_ID}/invoices`,
                storeId: this.STORE_ID,
                authHeader: `token ${this.API_KEY}`
            });

            const response = await axios.post(
                `${this.API_URL}/api/v1/stores/${this.STORE_ID}/invoices`,
                payload,
                {
                    headers: {
                        'Authorization': `token ${this.API_KEY}`,
                        'Content-Type': 'application/json'
                    }
                }
            );

            console.log('BTCPay API Response:', response.data);

            if (response.data && response.data.checkoutLink) {
                // Store payment record
                await pool.query(
                    `INSERT INTO payments (
                        order_record_id, provider, status_url, amount, 
                        payment_url, payid
                    ) VALUES ($1, $2, $3, $4, $5, $6)`,
                    [
                        orderData.record_id,
                        'BTCPAY',
                        'success',
                        formattedAmount,
                        response.data.checkoutLink,
                        response.data.id
                    ]
                );

                return response.data.checkoutLink;
            } else {
                throw new Error('Invalid response from BTCPay Server');
            }

        } catch (error) {
            console.error('\n=== BTCPay API Error ===');
            console.error('Error details:', {
                message: error.message,
                response: error.response?.data,
                order: orderData.trade_order,
                config: error.config
            });

            // Store failed payment record
            await pool.query(
                `INSERT INTO payments (
                    order_record_id, provider, status_url, amount, message_url
                ) VALUES ($1, $2, $3, $4, $5)`,
                [
                    orderData.record_id,
                    'BTCPAY',
                    'failed',
                    orderData.total_price,
                    error.response?.data?.message || error.message
                ]
            );

            throw error;
        }
    }
}

module.exports = new BTCPayService();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/payments/paymentService.js
/**
 * Payment Service
 * --------------
 * Purpose: Handles payment status checking
 * Role: Provides business logic for payment status
 * 
 * Key Functions:
 * - Check payment status by token
 * 
 * Dependencies:
 * - Database pool for queries
 * 
 * Supported Payment Methods:
 * - POLi Payments
 * - Blink Payments
 * - BTCPay (Bitcoin)
 * - Stripe (Credit Card)
 * - Alipay (via Stripe)
 */

const pool = require('../../config/database');

class PaymentService {
    /**
     * Gets payment status and available payment URLs by token
     * Includes all available payment methods for the order
     * @param {string} token - Order token
     * @returns {Object} Payment status and available payment URLs
     */
    async getStatusByToken(token) {
        console.log('Checking payment status for token:', token);

        const query = `
            SELECT 
                p.payment_url,
                p.status_url,
                p.created_at,
                p.message_url,
                p.provider,
                p.expires_at
            FROM payments p
            JOIN orders o ON o.record_id = p.order_record_id
            WHERE o.token = $1
            AND p.status_url = 'success'
            AND (p.expires_at IS NULL OR p.expires_at > NOW())
            ORDER BY p.created_at DESC
        `;

        try {
            const result = await pool.query(query, [token]);
            console.log('Payment status results:', result.rows);

            // If no payment records found
            if (!result.rows.length) {
                return { 
                    status: 'pending',
                    message: 'Payment processing' 
                };
            }

            // Create an object to hold payment URLs for all providers
            const paymentUrls = {};
            
            // Process all successful payment records
            result.rows.forEach(row => {
                if (row.status_url === 'success' && row.payment_url) {
                    paymentUrls[row.provider] = {
                        payment_url: row.payment_url,
                        provider: row.provider,
                        expires_at: row.expires_at
                    };
                }
            });

            return {
                status: 'success',
                payments: paymentUrls,
                checked_at: new Date().toISOString()
            };

        } catch (error) {
            console.error('Database error in getStatusByToken:', error);
            throw new Error('Failed to check payment status');
        }
    }

    /**
     * Utility method to format expiry timestamp
     * @private
     * @param {Date} date - Expiry date
     * @returns {string} Formatted timestamp
     */
    _formatExpiryTime(date) {
        return date.toISOString();
    }

    /**
     * Checks if a payment URL has expired
     * @private
     * @param {Date} expiryDate - Payment URL expiry date
     * @returns {boolean} True if expired
     */
    _isExpired(expiryDate) {
        return new Date() > new Date(expiryDate);
    }
}

module.exports = new PaymentService();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/expiry/providers/blinkExpiry.js
const axios = require('axios');

class BlinkExpiryProvider {
    constructor() {
        this.baseUrl = process.env.BLINK_API_BASE_URL;
    }

    async revokePayment(payid, token) {
        try {
            console.log(`Revoking Blink payment: ${payid}`);
            
            await axios.delete(
                `${this.baseUrl}/quick-payments/${payid}`,
                {
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    }
                }
            );

            console.log(`Successfully revoked Blink payment: ${payid}`);
            return true;
        } catch (error) {
            console.error(`Failed to revoke Blink payment ${payid}:`, error.response?.data || error.message);
            throw error;
        }
    }
}

module.exports = new BlinkExpiryProvider();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/expiry/expiryQueue.js
const Queue = require('bull');

const expiryQueue = new Queue('payment-expiry', process.env.REDIS_URL, {
    defaultJobOptions: {
        attempts: 3,
        backoff: {
            type: 'exponential',
            delay: 1000 // 1 second initial delay
        }
    }
});

// Log events for monitoring
expiryQueue.on('completed', job => {
    console.log(`Payment expiry job completed: ${job.id} for ${job.data.provider} payment ${job.data.payid}`);
});

expiryQueue.on('failed', (job, error) => {
    console.error(`Payment expiry job failed: ${job.id} for ${job.data.provider} payment ${job.data.payid}`, error);
});

module.exports = expiryQueue;----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/expiry/test-queue.js
require('dotenv').config();
const Queue = require('bull');

// Create a test queue
const testQueue = new Queue('test-queue', process.env.REDIS_URL);

// Add a test job
testQueue.add({ message: 'Test job' }, { delay: 5000 }); // 5 second delay

// Process jobs
testQueue.process(async (job) => {
    console.log('Processing job:', job.data.message);
    return { done: true };
});

// Listen for completed jobs
testQueue.on('completed', (job, result) => {
    console.log('Job completed with result:', result);
    process.exit(0);
});

console.log('Test started - waiting 5 seconds for job to process...');----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/expiry/expiryService.js
/*
----------------------------------------------
commented out service. empty service below to not start the expiry checker 
---------------------------------------------------

const pool = require('../../config/database');
const expiryQueue = require('./expiryQueue');
const blinkExpiry = require('./providers/blinkExpiry');
const blinkService = require('../payments/blinkService'); // Changed to use instance

class PaymentExpiryService {
    constructor() {
        this.setupQueueProcessor();
    }

    setupQueueProcessor() {
        expiryQueue.process(async (job) => {
            const { payid, provider } = job.data;
            console.log(`Processing expiry for ${provider} payment ${payid}`);
            
            try {
                await this.processExpiry(payid, provider);
                return { success: true, payid, provider };
            } catch (error) {
                // Check if error is due to payment already being expired or invalid
                if (error.response?.status === 404 || error.response?.status === 410) {
                    console.log(`Payment ${payid} already expired or invalid`);
                    await this.updatePaymentStatus(payid, 'expired', 'Payment already expired');
                    return { success: true, payid, provider, status: 'already_expired' };
                }

                console.error(`Expiry processing failed for ${payid}:`, error);
                throw error;
            }
        });
    }

    async updatePaymentStatus(payid, status, message) {
        const client = await pool.connect();
        try {
            await client.query(
                `UPDATE payments 
                 SET status = $1, 
                     error_message = $2
                 WHERE payid = $3`,
                [status, message, payid]
            );
        } finally {
            client.release();
        }
    }

    async processExpiry(payid, provider) {
        const client = await pool.connect();
        
        try {
            await client.query('BEGIN');

            // Get payment details
            const { rows } = await client.query(
                'SELECT * FROM payments WHERE payid = $1 AND provider = $2',
                [payid, provider]
            );

            if (!rows.length) {
                throw new Error(`Payment ${payid} not found`);
            }

            const payment = rows[0];

            // Only process if payment is still active
            if (payment.status === 'success') {
                // Handle provider-specific revocation
                switch (provider) {
                    case 'BLINK':
                        const token = await blinkService.ensureValidToken();
                        await blinkExpiry.revokePayment(payid, token);
                        break;
                    default:
                        throw new Error(`Unsupported payment provider: ${provider}`);
                }

                // Update payment status
                await client.query(
                    `UPDATE payments 
                     SET status = 'expired', 
                         error_message = 'Payment link expired'
                     WHERE payid = $1`,
                    [payid]
                );

                console.log(`Successfully expired ${provider} payment ${payid}`);
            } else {
                console.log(`Payment ${payid} already in ${payment.status} status, skipping expiry`);
            }

            await client.query('COMMIT');
        } catch (error) {
            await client.query('ROLLBACK');
            throw error;
        } finally {
            client.release();
        }
    }

    async scheduleExpiry(payid, provider) {
        // Set expiry slightly shorter than Blink's expiry to ensure we revoke first
        const expiryMinutes = (parseInt(process.env.BLINK_PAYMENT_EXPIRY_MINUTES) || 30) - 2;
        
        console.log(`Scheduling expiry for ${provider} payment ${payid} in ${expiryMinutes} minutes`);
        
        // Schedule job
        await expiryQueue.add(
            { payid, provider },
            { 
                delay: expiryMinutes * 60 * 1000,
                jobId: `${provider}-${payid}`,
                attempts: 3,
                backoff: {
                    type: 'exponential',
                    delay: 1000
                }
            }
        );

        console.log(`Expiry scheduled for ${provider} payment ${payid}`);
    }
}

module.exports = new PaymentExpiryService();


*/


const pool = require('../../config/database');
const blinkExpiry = require('./providers/blinkExpiry');
const blinkService = require('../payments/blinkService'); // Changed to use instance

class PaymentExpiryService {
    constructor() {
        this.setupQueueProcessor();
    }

    setupQueueProcessor() {
        // No processing setup required as we are disabling the expiry queue
    }

    async updatePaymentStatus(payid, status, message) {
        const client = await pool.connect();
        try {
            await client.query(
                `UPDATE payments 
                 SET status = $1, 
                     error_message = $2
                 WHERE payid = $3`,
                [status, message, payid]
            );
        } finally {
            client.release();
        }
    }

    async processExpiry(payid, provider) {
        const client = await pool.connect();
        
        try {
            await client.query('BEGIN');

            // Get payment details
            const { rows } = await client.query(
                'SELECT * FROM payments WHERE payid = $1 AND provider = $2',
                [payid, provider]
            );

            if (!rows.length) {
                throw new Error(`Payment ${payid} not found`);
            }

            const payment = rows[0];

            // Only process if payment is still active
            if (payment.status === 'success') {
                // Handle provider-specific revocation
                switch (provider) {
                    case 'BLINK':
                        const token = await blinkService.ensureValidToken();
                        await blinkExpiry.revokePayment(payid, token);
                        break;
                    default:
                        throw new Error(`Unsupported payment provider: ${provider}`);
                }

                // Update payment status
                await client.query(
                    `UPDATE payments 
                     SET status = 'expired', 
                         error_message = 'Payment link expired'
                     WHERE payid = $1`,
                    [payid]
                );

                console.log(`Successfully expired ${provider} payment ${payid}`);
            } else {
                console.log(`Payment ${payid} already in ${payment.status} status, skipping expiry`);
            }

            await client.query('COMMIT');
        } catch (error) {
            await client.query('ROLLBACK');
            throw error;
        } finally {
            client.release();
        }
    }

    async scheduleExpiry(payid, provider) {
        // This method is intentionally left blank to disable expiry scheduling
    }
}

module.exports = new PaymentExpiryService();----------------------------------------
-e 
=== File: /workspaces/mware3/src/services/orders/orderService.js
/**
 * Order Service Module
 * ===================
 * This service handles the creation and management of orders in the system.
 * It provides functionality for:
 * - Generating unique trade order numbers
 * - Creating new orders with customer and product details
 * - Managing order transactions with database integration
 * - Generating payment links through multiple payment providers
 * 
 * Key Requirements:
 * - PostgreSQL database connection
 * - JWT for token generation
 * - POLi payment service integration
 * - Blink payment service integration
 * - BTCPay Server integration for Bitcoin payments
 * - Stripe payment service integration
 * - Alipay payment service integration
 * - Environment variables for JWT secret
 */

const pool = require('../../config/database');
const jwt = require('jsonwebtoken');
const PoliService = require('../payments/poliService');
const BlinkService = require('../payments/blinkService');
const BTCPayService = require('../payments/btcpayService');
const StripeService = require('../payments/stripeService');
const AlipayService = require('../payments/alipayService');

class OrderService {
    /**
     * Generates the next sequential trade order number
     * Formats: "TO-XXXX" where XXXX is an incrementing number
     * Default starts at TO-2317 if no previous orders exist
     */
    async getNextTradeOrder() {
        const result = await pool.query("SELECT trade_order FROM orders ORDER BY record_id DESC LIMIT 1");

        // ⚠️ CONFIGURE: Change starting number if needed
        const DEFAULT_START = "TO-2317";

        if (result.rows.length === 0 || !result.rows[0].trade_order || result.rows[0].trade_order.trim() === "") {
            return DEFAULT_START;
        }

        const lastTradeOrder = result.rows[0].trade_order.trim();

        if (typeof lastTradeOrder === "string" && lastTradeOrder.startsWith("TO-")) {
            const lastNumber = parseInt(lastTradeOrder.replace("TO-", ""), 10);
            return `TO-${lastNumber + 1}`;
        }

        return DEFAULT_START;
    }

    /**
     * Creates a new order in the system
     * @param {Object} orderData - Contains all order details including customer info and product details
     * @returns {Object} Contains generated token and trade order number
     */
    async createOrder(orderData) {
        const {
            first_name_order, email_order, total_price, // Required fields
            last_name_order, phone_order, product_name_full, quantity, price_nzd,
            zoho_id, delivery, pay_in_person, checkbox_order, address, message,
            date_picker_order, time_picker_order
        } = orderData;

        // Input validation for required fields
        if (!first_name_order || !email_order || !total_price) {
            throw new Error("First name, email, and total price are required.");
        }

        const trade_order = await this.getNextTradeOrder();

        // Database transaction handling
        const client = await pool.connect();
        try {
            await client.query('BEGIN');

            // Generate JWT token for order tracking
            const token = jwt.sign(
                { trade_order, email_order, timestamp: Date.now() },
                process.env.JWT_SECRET || "default_secret",
                { expiresIn: "1h" }
            );

            // Insert order into database
            const orderResult = await client.query(
                `INSERT INTO orders (
                    trade_order, first_name_order, last_name_order, email_order, phone_order,
                    product_name_full, total_price, quantity, price_nzd, zoho_id, delivery,
                    pay_in_person, checkbox_order, address, message, token,
                    date_picker_order, time_picker_order
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
                RETURNING record_id, order_creation_time`,
                [
                    trade_order, first_name_order, last_name_order || null, email_order, phone_order || null,
                    product_name_full || null, total_price, quantity || null, price_nzd || null, zoho_id || null,
                    delivery || null, pay_in_person || null, checkbox_order || null, address || null,
                    message || null, token, date_picker_order || null, time_picker_order || null
                ]
            );

            await client.query('COMMIT');

            // Prepare order data for payment processing
            const orderWithId = {
                ...orderData,
                record_id: orderResult.rows[0].record_id,
                trade_order
            };

            // Format timestamp for New Zealand timezone
            const timestamp = orderResult.rows[0].order_creation_time;
            const formattedDate = new Date(timestamp).toLocaleString('en-NZ', {
                timeZone: 'Pacific/Auckland',
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            }).replace(/\//g, '-');

            // Asynchronously generate payment links
            this.generatePaymentLinks(orderWithId);

            return { token, trade_order, order_creation_time: formattedDate };

        } catch (error) {
            await client.query('ROLLBACK');
            throw error;
        } finally {
            client.release();
        }
    }

    /**
     * Generates payment links through multiple payment providers
     * Runs asynchronously to not block the order creation process
     * Handles all payment processing in parallel
     * @param {Object} orderData - Complete order information including record_id
     */
    async generatePaymentLinks(orderData) {
        try {
            console.log('\n=== Starting Payment Processing ===');
            console.log('Processing order:', orderData.trade_order);
            
            await Promise.all([
                // POLi payment processing
                (async () => {
                    try {
                        await PoliService.generatePaymentLink(orderData);
                    } catch (error) {
                        console.error('POLi processing failed:', error.message);
                    }
                })(),
                // Blink payment processing
                (async () => {
                    try {
                        await BlinkService.generatePaymentLink(orderData);
                    } catch (error) {
                        console.error('Blink processing failed:', error.message);
                    }
                })(),
                // BTCPay processing
                (async () => {
                    try {
                        if (process.env.BTCPAY_API_KEY && process.env.BTCPAY_STORE_ID) {
                            await BTCPayService.generatePaymentLink(orderData);
                        } else {
                            console.log('BTCPay configuration not found, skipping Bitcoin payment processing');
                        }
                    } catch (error) {
                        console.error('BTCPay processing failed:', error.message);
                    }
                })(),
                // Stripe payment processing
                (async () => {
                    try {
                        if (process.env.STRIPE_SECRET_KEY) {
                            await StripeService.generatePaymentLink(orderData);
                        } else {
                            console.log('Stripe configuration not found, skipping Stripe payment processing');
                        }
                    } catch (error) {
                        console.error('Stripe processing failed:', error.message);
                    }
                })(),
                // Alipay processing
                (async () => {
                    try {
                        if (process.env.STRIPE_ALIPAY_FEE) {
                            await AlipayService.generatePaymentLink(orderData);
                        } else {
                            console.log('Alipay configuration not found, skipping Alipay payment processing');
                        }
                    } catch (error) {
                        console.error('Alipay processing failed:', error.message);
                    }
                })()
            ]);

            console.log('=== Payment Processing Complete ===\n');
        } catch (error) {
            console.error('Payment link generation failed:', error);
            // Don't throw - this is background processing
        }
    }
}

module.exports = new OrderService();----------------------------------------

=== File: package.json ===
{
  "name": "mware3",
  "version": "1.0.0",
  "description": "Middleware for Webflow Integration",
  "main": "server.js",
  "engines": {
    "node": "20.18.1"
  },
  "scripts": {
    "start": "node server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "middleware",
    "webflow",
    "nodejs"
  ],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "axios": "^1.3.4",
    "bull": "^4.16.5",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "express-rate-limit": "^7.5.0",
    "ioredis": "^5.5.0",
    "jsonwebtoken": "^9.0.0",
    "pg": "^8.10.0",
    "puppeteer": "^24.2.0"
  }
}
----------------------------------------
